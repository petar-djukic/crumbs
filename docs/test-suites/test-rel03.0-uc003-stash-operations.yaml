id: test-rel03.0-uc003-stash-operations
title: Stash operations for all stash types
description: >
  Validates stash creation for all five stash types (resource, artifact, context,
  counter, lock), value operations (SetValue/GetValue), counter operations (Increment),
  lock operations (Acquire/Release) including reentrant and contention semantics,
  version tracking across mutations, and filtering through the Table interface.
traces:
  - rel03.0-uc003-stash-operations
tags:
  - integration
  - stashes
  - coordination

preconditions:
  - Cupboard initialized with SQLite backend
  - stashes table accessible via GetTable
  - No existing stashes in the database

test_cases:

  # --- S1: Stash created via Table.Set generates UUID v7 for StashID ---

  - name: Create stash generates UUID v7
    inputs:
      command: |
        stash := &Stash{Name: "test-stash", StashType: "context", Value: map[string]any{"key": "value"}, Version: 1}
        stashesTable.Set("", stash)
    expected:
      exit_code: 0
      state:
        stash_id_generated: true
        stash_id_is_uuid_v7: true
        created_at_set: true

  - name: Set with existing ID updates stash
    inputs:
      setup:
        - Create context stash
      command: |
        stash.Value = map[string]any{"updated": true}
        stashesTable.Set(stash.StashID, stash)
    expected:
      exit_code: 0
      state:
        value_updated: true

  # --- S2: All five stash types can be created ---

  - name: Create resource stash
    inputs:
      command: |
        stash := &Stash{Name: "api-connection", StashType: "resource", Value: map[string]any{"uri": "https://api.example.com", "kind": "http"}, Version: 1}
        stashesTable.Set("", stash)
    expected:
      exit_code: 0
      state:
        stash_type: resource
        value_has_uri: true
        value_has_kind: true

  - name: Create artifact stash
    inputs:
      command: |
        stash := &Stash{Name: "build-output", StashType: "artifact", Value: map[string]any{"path": "/tmp/build.zip", "producer": "build-agent"}, Version: 1}
        stashesTable.Set("", stash)
    expected:
      exit_code: 0
      state:
        stash_type: artifact
        value_has_path: true
        value_has_producer: true

  - name: Create context stash
    inputs:
      command: |
        stash := &Stash{Name: "shared-config", StashType: "context", Value: map[string]any{"timeout": 30, "retries": 3}, Version: 1}
        stashesTable.Set("", stash)
    expected:
      exit_code: 0
      state:
        stash_type: context
        value_has_timeout: true

  - name: Create counter stash
    inputs:
      command: |
        stash := &Stash{Name: "request-counter", StashType: "counter", Value: map[string]any{"value": 0}, Version: 1}
        stashesTable.Set("", stash)
    expected:
      exit_code: 0
      state:
        stash_type: counter
        initial_value: 0

  - name: Create lock stash
    inputs:
      command: |
        stash := &Stash{Name: "resource-lock", StashType: "lock", Value: nil, Version: 1}
        stashesTable.Set("", stash)
    expected:
      exit_code: 0
      state:
        stash_type: lock
        value_is_nil: true

  # --- S3: SetValue updates value and increments Version ---

  - name: SetValue updates value and increments version
    inputs:
      setup:
        - Create context stash with Version 1
      command: |
        stash.SetValue(map[string]any{"timeout": 60})
        stashesTable.Set(stash.StashID, stash)
    expected:
      exit_code: 0
      state:
        value_timeout: 60
        version: 2

  - name: SetValue on lock type returns ErrInvalidStashType
    inputs:
      setup:
        - Create lock stash
      command: stash.SetValue(map[string]any{"invalid": true})
    expected:
      error: ErrInvalidStashType

  # --- S4: GetValue returns current value ---

  - name: GetValue returns current value
    inputs:
      setup:
        - Create context stash with value {"key": "original"}
      command: stash.GetValue()
    expected:
      state:
        value_key: original

  - name: GetValue returns nil for empty stash
    inputs:
      setup:
        - Create lock stash with nil value
      command: stash.GetValue()
    expected:
      state:
        value_is_nil: true

  # --- S5, S6: Increment adds delta to counter value ---

  - name: Increment with positive delta
    inputs:
      setup:
        - Create counter stash with value 0
      command: |
        newVal, err := stash.Increment(5)
        stashesTable.Set(stash.StashID, stash)
    expected:
      exit_code: 0
      state:
        new_value: 5
        version_incremented: true

  - name: Increment with negative delta
    inputs:
      setup:
        - Create counter stash with value 10
      command: |
        newVal, err := stash.Increment(-3)
        stashesTable.Set(stash.StashID, stash)
    expected:
      exit_code: 0
      state:
        new_value: 7
        version_incremented: true

  - name: Multiple increments accumulate correctly
    inputs:
      setup:
        - Create counter stash with value 0
      steps:
        - "stash.Increment(10) // returns 10"
        - "stash.Increment(-3) // returns 7"
        - "stash.Increment(5) // returns 12"
        - stashesTable.Set(stash.StashID, stash)
    expected:
      state:
        final_value: 12
        version: 4

  - name: Increment on non-counter returns ErrInvalidStashType
    inputs:
      setup:
        - Create context stash
      command: stash.Increment(1)
    expected:
      error: ErrInvalidStashType

  # --- S7, S8, S9: Lock operations ---

  - name: Acquire lock sets holder and increments version
    inputs:
      setup:
        - Create lock stash with nil value
      command: |
        err := stash.Acquire("worker-1")
        stashesTable.Set(stash.StashID, stash)
    expected:
      exit_code: 0
      state:
        holder: worker-1
        acquired_at_set: true
        version_incremented: true

  - name: Acquire by same holder succeeds (reentrant)
    inputs:
      setup:
        - Create lock stash
        - Acquire lock with holder "worker-1"
      command: stash.Acquire("worker-1")
    expected:
      exit_code: 0
      state:
        holder: worker-1

  - name: Acquire by different holder returns ErrLockHeld
    inputs:
      setup:
        - Create lock stash
        - Acquire lock with holder "worker-1"
      command: stash.Acquire("worker-2")
    expected:
      error: ErrLockHeld

  - name: Acquire with empty holder returns ErrInvalidHolder
    inputs:
      setup:
        - Create lock stash
      command: stash.Acquire("")
    expected:
      error: ErrInvalidHolder

  - name: Acquire on non-lock returns ErrInvalidStashType
    inputs:
      setup:
        - Create context stash
      command: stash.Acquire("worker-1")
    expected:
      error: ErrInvalidStashType

  - name: Release lock clears value and increments version
    inputs:
      setup:
        - Create lock stash
        - Acquire lock with holder "worker-1"
      command: |
        err := stash.Release("worker-1")
        stashesTable.Set(stash.StashID, stash)
    expected:
      exit_code: 0
      state:
        value_is_nil: true
        version_incremented: true

  - name: Release by wrong holder returns ErrNotLockHolder
    inputs:
      setup:
        - Create lock stash
        - Acquire lock with holder "worker-1"
      command: stash.Release("worker-2")
    expected:
      error: ErrNotLockHolder

  - name: Release on unheld lock returns ErrNotLockHolder
    inputs:
      setup:
        - Create lock stash with nil value
      command: stash.Release("worker-1")
    expected:
      error: ErrNotLockHolder

  - name: Release on non-lock returns ErrInvalidStashType
    inputs:
      setup:
        - Create context stash
      command: stash.Release("worker-1")
    expected:
      error: ErrInvalidStashType

  # --- S10: Version tracking ---

  - name: Version starts at 1 on creation
    inputs:
      command: |
        stash := &Stash{Name: "version-test", StashType: "context", Value: map[string]any{}, Version: 1}
        stashesTable.Set("", stash)
    expected:
      state:
        version: 1

  - name: Version increments on each mutation
    inputs:
      setup:
        - Create counter stash with version 1
      steps:
        - "stash.Increment(1) // version 2"
        - "stash.Increment(1) // version 3"
        - "stash.Increment(1) // version 4"
    expected:
      state:
        version: 4

  # --- S11, S12: Fetch with filters ---

  - name: Fetch by stash_type returns only matching stashes
    inputs:
      setup:
        - Create counter stash "counter-1"
        - Create context stash "context-1"
        - Create lock stash "lock-1"
      command: |
        filter := map[string]any{"StashType": "counter"}
        stashesTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 1
        all_results_type: counter

  - name: Fetch by name returns matching stash
    inputs:
      setup:
        - Create context stash "shared-config"
        - Create context stash "other-config"
      command: |
        filter := map[string]any{"Name": "shared-config"}
        stashesTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 1
        result_name: shared-config

  - name: Fetch with no filter returns all stashes
    inputs:
      setup:
        - Create stashes of each type
      command: stashesTable.Fetch(nil)
    expected:
      exit_code: 0
      state:
        result_count: 5

  - name: Fetch with no matches returns empty slice
    inputs:
      setup:
        - Create context stash
      command: |
        filter := map[string]any{"StashType": "nonexistent"}
        stashesTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 0

  # --- S13: Delete stash ---

  - name: Delete stash removes it
    inputs:
      setup:
        - Create context stash
      steps:
        - stashesTable.Delete(stash.StashID)
        - stashesTable.Get(stash.StashID)
    expected:
      state:
        delete_succeeds: true
        get_error: ErrNotFound

  - name: Delete nonexistent stash returns ErrNotFound
    inputs:
      command: stashesTable.Delete("nonexistent-uuid-12345")
    expected:
      error: ErrNotFound

  - name: Delete with empty ID returns ErrInvalidID
    inputs:
      command: stashesTable.Delete("")
    expected:
      error: ErrInvalidID

  # --- S14, S15: Stash history tracking ---

  - name: History entry created on stash creation
    inputs:
      command: |
        stash := &Stash{Name: "history-test", StashType: "context", Value: map[string]any{"key": "value"}, Version: 1}
        stashesTable.Set("", stash)
        table.FetchStashHistory(stash.StashID)
    expected:
      exit_code: 0
      state:
        history_count: 1
        first_entry_operation: create
        first_entry_version: 1

  - name: History entry created on SetValue
    inputs:
      setup:
        - Create context stash with Version 1
      command: |
        stash.SetValue(map[string]any{"updated": true})
        stashesTable.Set(stash.StashID, stash)
        table.FetchStashHistory(stash.StashID)
    expected:
      exit_code: 0
      state:
        history_count: 2
        last_entry_operation: set
        last_entry_version: 2

  - name: History entry created on Increment
    inputs:
      setup:
        - Create counter stash with Version 1
      command: |
        stash.Increment(5)
        stashesTable.Set(stash.StashID, stash)
        table.FetchStashHistory(stash.StashID)
    expected:
      exit_code: 0
      state:
        history_count: 2
        last_entry_operation: increment
        last_entry_version: 2

  - name: History entry created on Acquire
    inputs:
      setup:
        - Create lock stash with Version 1
      command: |
        stash.Acquire("worker-1")
        stashesTable.Set(stash.StashID, stash)
        table.FetchStashHistory(stash.StashID)
    expected:
      exit_code: 0
      state:
        history_count: 2
        last_entry_operation: acquire
        last_entry_version: 2

  - name: History entry created on Release
    inputs:
      setup:
        - Create lock stash with Version 1
        - Acquire lock
      command: |
        stash.Release("worker-1")
        stashesTable.Set(stash.StashID, stash)
        table.FetchStashHistory(stash.StashID)
    expected:
      exit_code: 0
      state:
        history_count: 3
        last_entry_operation: release
        last_entry_version: 3

  - name: FetchStashHistory returns entries ordered by version
    inputs:
      setup:
        - Create counter stash
        - Increment three times
      command: table.FetchStashHistory(stash.StashID)
    expected:
      exit_code: 0
      state:
        history_count: 4
        versions_ascending: true
        operations: [create, increment, increment, increment]

  - name: FetchStashHistory with empty ID returns ErrInvalidID
    inputs:
      command: table.FetchStashHistory("")
    expected:
      error: ErrInvalidID

  - name: FetchStashHistory for nonexistent stash returns empty list
    inputs:
      command: table.FetchStashHistory("nonexistent-uuid")
    expected:
      exit_code: 0
      state:
        history_count: 0

  - name: History entries include value snapshots
    inputs:
      setup:
        - Create counter stash with value 0
      steps:
        - "stash.Increment(10) and Set"
        - "stash.Increment(5) and Set"
      command: table.FetchStashHistory(stash.StashID)
    expected:
      state:
        history_values: [0, 10, 15]

  # --- Full workflow test ---

  - name: Full stash operations workflow
    description: >
      Create stashes of each type, exercise type-specific operations,
      verify version tracking, filter queries, and cleanup.
    inputs:
      steps:
        - Create resource stash "api-conn"
        - Create artifact stash "build-out"
        - Create context stash "shared-cfg"
        - Create counter stash "req-counter"
        - Create lock stash "mutex"
        - "SetValue on context: update timeout to 60"
        - "Increment counter by 10, then -3, then 5 (expect 12)"
        - "Acquire lock with worker-1"
        - "Try acquire with worker-2 (expect ErrLockHeld)"
        - "Release lock with worker-1"
        - "Acquire lock with worker-2 (success)"
        - Verify version tracking for each stash
        - Fetch by stash_type "counter" (expect 1)
        - Fetch by stash_type "lock" (expect 1)
        - Delete context stash
        - Fetch all (expect 4)
    expected:
      state:
        initial_stash_count: 5
        context_value_after_set: 60
        counter_value_after_increments: 12
        lock_holder_after_release_reacquire: worker-2
        final_stash_count: 4

cleanup:
  - Remove temp data directory
  - Detach cupboard
