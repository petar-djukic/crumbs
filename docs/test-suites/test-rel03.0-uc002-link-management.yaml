id: test-rel03.0-uc002-link-management
title: Link management CRUD and filtering
description: >
  Validates link creation for all four link types (belongs_to, child_of,
  branches_from, scoped_to), retrieval, filtering, and deletion through
  the Table interface. Each test case creates prerequisite entities
  before establishing links between them.
traces:
  - rel03.0-uc002-link-management
tags:
  - integration
  - links
  - graph

preconditions:
  - Cupboard initialized with SQLite backend
  - links, crumbs, trails, and stashes tables accessible via GetTable
  - No existing links in the database

test_cases:

  # --- S1: Link created via Table.Set generates UUID v7 for LinkID ---

  - name: Create link generates UUID v7
    description: >
      Creating a link with empty ID generates a UUID v7 for LinkID and sets CreatedAt.
    inputs:
      setup:
        - Create trail in active state
        - Create crumb in draft state
      command: |
        link := &Link{LinkType: "belongs_to", FromID: crumb.CrumbID, ToID: trail.TrailID}
        id, err := linksTable.Set("", link)
    expected:
      exit_code: 0
      state:
        returned_id_not_empty: true
        returned_id_is_uuid_v7: true
        link_linkid_equals_returned_id: true
        link_createdat_not_zero: true

  - name: Set with existing ID updates link
    description: >
      Calling Set with an existing link ID updates the link fields.
    inputs:
      setup:
        - Create trail and two crumbs
        - Create belongs_to link from crumb1 to trail
      command: |
        link.FromID = crumb2.CrumbID
        linksTable.Set(linkID, link)
    expected:
      exit_code: 0
      state:
        retrieved_link_from_id: crumb2_id

  # --- S2: belongs_to link associates crumb with trail ---

  - name: Create belongs_to link for crumb-trail membership
    description: >
      A belongs_to link associates a crumb with a trail. FromID is the crumb,
      ToID is the trail.
    inputs:
      setup:
        - Create trail in active state
        - Create crumb in draft state
      command: |
        link := &Link{LinkType: "belongs_to", FromID: crumb.CrumbID, ToID: trail.TrailID}
        id, err := linksTable.Set("", link)
        entity, err := linksTable.Get(id)
    expected:
      exit_code: 0
      state:
        link_type: belongs_to
        link_from_id: crumb_id
        link_to_id: trail_id

  # --- S3: child_of link establishes crumb hierarchy ---

  - name: Create child_of link for crumb hierarchy
    description: >
      A child_of link establishes a parent-child hierarchy between crumbs.
      FromID is the child crumb, ToID is the parent crumb.
    inputs:
      setup:
        - Create parent crumb (epic) in draft state
        - Create child crumb (task) in draft state
      command: |
        link := &Link{LinkType: "child_of", FromID: child.CrumbID, ToID: parent.CrumbID}
        id, err := linksTable.Set("", link)
        entity, err := linksTable.Get(id)
    expected:
      exit_code: 0
      state:
        link_type: child_of
        link_from_id: child_crumb_id
        link_to_id: parent_crumb_id

  - name: Query children of parent crumb
    description: >
      Fetch with LinkType=child_of and ToID=parent returns all child links.
    inputs:
      setup:
        - Create parent crumb
        - Create child1 and child2 crumbs
        - Create child_of links from both children to parent
      command: |
        filter := map[string]any{"LinkType": "child_of", "ToID": parent.CrumbID}
        entities, err := linksTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 2
        result_from_ids_include: [child1_id, child2_id]

  - name: Query parent of child crumb
    description: >
      Fetch with LinkType=child_of and FromID=child returns the parent link.
    inputs:
      setup:
        - Create parent crumb
        - Create child crumb
        - Create child_of link from child to parent
      command: |
        filter := map[string]any{"LinkType": "child_of", "FromID": child.CrumbID}
        entities, err := linksTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 1
        result_to_id: parent_crumb_id

  # --- S4: branches_from link indicates trail branch point ---

  - name: Create branches_from link for trail branch point
    description: >
      A branches_from link indicates where a trail branched from a crumb.
      FromID is the trail, ToID is the branch point crumb.
    inputs:
      setup:
        - Create branch point crumb (decision point)
        - Create trail in active state
      command: |
        link := &Link{LinkType: "branches_from", FromID: trail.TrailID, ToID: crumb.CrumbID}
        id, err := linksTable.Set("", link)
        entity, err := linksTable.Get(id)
    expected:
      exit_code: 0
      state:
        link_type: branches_from
        link_from_id: trail_id
        link_to_id: branch_point_crumb_id

  - name: Query branch point of trail
    description: >
      Fetch with LinkType=branches_from and FromID=trail returns the branch point.
    inputs:
      setup:
        - Create branch point crumb
        - Create trail and branches_from link
      command: |
        filter := map[string]any{"LinkType": "branches_from", "FromID": trail.TrailID}
        entities, err := linksTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 1
        result_to_id: branch_point_crumb_id

  # --- S5: scoped_to link scopes stash to trail ---

  - name: Create scoped_to link for stash trail scope
    description: >
      A scoped_to link scopes a stash to a trail. FromID is the stash,
      ToID is the trail.
    inputs:
      setup:
        - Create trail in active state
        - Create stash with type context
      command: |
        link := &Link{LinkType: "scoped_to", FromID: stash.StashID, ToID: trail.TrailID}
        id, err := linksTable.Set("", link)
        entity, err := linksTable.Get(id)
    expected:
      exit_code: 0
      state:
        link_type: scoped_to
        link_from_id: stash_id
        link_to_id: trail_id

  - name: Query stashes scoped to trail
    description: >
      Fetch with LinkType=scoped_to and ToID=trail returns all scoped stash links.
    inputs:
      setup:
        - Create trail
        - Create stash1 and stash2
        - Create scoped_to links from both stashes to trail
      command: |
        filter := map[string]any{"LinkType": "scoped_to", "ToID": trail.TrailID}
        entities, err := linksTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 2

  - name: Query trail scope of stash
    description: >
      Fetch with LinkType=scoped_to and FromID=stash returns the trail scope.
    inputs:
      setup:
        - Create trail
        - Create stash and scoped_to link
      command: |
        filter := map[string]any{"LinkType": "scoped_to", "FromID": stash.StashID}
        entities, err := linksTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 1
        result_to_id: trail_id

  # --- S6: Fetch with link_type filter returns only links of that type ---

  - name: Fetch by link_type returns only matching links
    description: >
      Fetch with LinkType filter returns only links of that type.
    inputs:
      setup:
        - Create trail, crumbs, stash
        - Create one belongs_to link, one child_of link, one scoped_to link
      command: |
        filter := map[string]any{"LinkType": "belongs_to"}
        entities, err := linksTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 1
        all_results_link_type: belongs_to

  - name: Fetch all links without filter
    description: >
      Fetch with nil filter returns all links of all types.
    inputs:
      setup:
        - Create trail, crumbs, stash
        - Create one belongs_to, one child_of, one scoped_to link
      command: |
        entities, err := linksTable.Fetch(nil)
    expected:
      exit_code: 0
      state:
        result_count: 3
        link_types_present: [belongs_to, child_of, scoped_to]

  # --- S7: Fetch with from_id filter returns links originating from that entity ---

  - name: Fetch by from_id returns links from that entity
    description: >
      Fetch with FromID filter returns links originating from that entity.
    inputs:
      setup:
        - Create trail and crumb
        - Create belongs_to link from crumb to trail
      command: |
        filter := map[string]any{"FromID": crumb.CrumbID}
        entities, err := linksTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 1
        result_from_id: crumb_id

  - name: Fetch by from_id with no matches returns empty
    description: >
      Fetch with FromID that has no links returns an empty slice.
    inputs:
      setup:
        - Create trail and crumb
        - Create belongs_to link
      command: |
        filter := map[string]any{"FromID": "nonexistent-id"}
        entities, err := linksTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 0

  # --- S8: Fetch with to_id filter returns links targeting that entity ---

  - name: Fetch by to_id returns links to that entity
    description: >
      Fetch with ToID filter returns links targeting that entity.
    inputs:
      setup:
        - Create trail
        - Create crumb1 and crumb2
        - Create belongs_to links from both crumbs to trail
      command: |
        filter := map[string]any{"ToID": trail.TrailID}
        entities, err := linksTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 2
        all_results_to_id: trail_id

  - name: Fetch by to_id with no matches returns empty
    description: >
      Fetch with ToID that has no links returns an empty slice.
    inputs:
      setup:
        - Create trail and crumb
        - Create belongs_to link
      command: |
        filter := map[string]any{"ToID": "nonexistent-id"}
        entities, err := linksTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 0

  # --- Combined filter tests ---

  - name: Fetch with link_type and to_id combined
    description: >
      Fetch with both LinkType and ToID filters returns links matching both criteria.
    inputs:
      setup:
        - Create trail
        - Create crumb1 and crumb2
        - Create belongs_to link from crumb1 to trail
        - Create child_of link from crumb2 to crumb1
      command: |
        filter := map[string]any{"LinkType": "belongs_to", "ToID": trail.TrailID}
        entities, err := linksTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 1
        result_link_type: belongs_to
        result_to_id: trail_id

  - name: Fetch with all three filters
    description: >
      Fetch with LinkType, FromID, and ToID filters returns the exact match.
    inputs:
      setup:
        - Create trail and crumb
        - Create belongs_to link
      command: |
        filter := map[string]any{
          "LinkType": "belongs_to",
          "FromID": crumb.CrumbID,
          "ToID": trail.TrailID,
        }
        entities, err := linksTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 1

  # --- S9: Delete removes link; subsequent Get returns ErrNotFound ---

  - name: Delete link removes it
    description: >
      Delete removes a link. Subsequent Get returns ErrNotFound.
    inputs:
      setup:
        - Create trail and crumb
        - Create belongs_to link
      command: |
        err := linksTable.Delete(linkID)
        _, err = linksTable.Get(linkID)
    expected:
      state:
        delete_error: nil
        get_error: ErrNotFound

  - name: Delete link does not affect other links
    description: >
      Deleting one link does not affect other links in the table.
    inputs:
      setup:
        - Create trail
        - Create crumb1 and crumb2
        - Create belongs_to link1 from crumb1 to trail
        - Create belongs_to link2 from crumb2 to trail
      command: |
        err := linksTable.Delete(link1ID)
        entity, err := linksTable.Get(link2ID)
    expected:
      state:
        delete_error: nil
        link2_exists: true

  # --- S10: Delete of nonexistent link returns ErrNotFound ---

  - name: Delete nonexistent link returns ErrNotFound
    description: >
      Delete with a nonexistent ID returns ErrNotFound.
    inputs:
      command: |
        err := linksTable.Delete("nonexistent-uuid-12345")
    expected:
      error: ErrNotFound

  - name: Delete with empty ID returns ErrInvalidID
    description: >
      Delete with an empty string ID returns ErrInvalidID.
    inputs:
      command: |
        err := linksTable.Delete("")
    expected:
      error: ErrInvalidID

  # --- Additional edge cases ---

  - name: Get with empty ID returns ErrInvalidID
    description: >
      Get with an empty string ID returns ErrInvalidID.
    inputs:
      command: |
        _, err := linksTable.Get("")
    expected:
      error: ErrInvalidID

  - name: Get nonexistent link returns ErrNotFound
    description: >
      Get with a nonexistent ID returns ErrNotFound.
    inputs:
      command: |
        _, err := linksTable.Get("nonexistent-uuid-12345")
    expected:
      error: ErrNotFound

  - name: Fetch empty table returns empty slice
    description: >
      Fetch on an empty table returns an empty slice, not nil.
    inputs:
      command: |
        entities, err := linksTable.Fetch(nil)
    expected:
      exit_code: 0
      state:
        result_count: 0

  # --- Full workflow test ---

  - name: Full link management workflow
    description: >
      Creates entities, establishes all four link types, queries via filters,
      deletes a link, and verifies final state. Validates the complete link
      management lifecycle.
    inputs:
      steps:
        - Create trail in active state
        - Create parentCrumb (epic) and childCrumb (task)
        - Create stash (context type)
        - Create belongs_to link from childCrumb to trail
        - Create child_of link from childCrumb to parentCrumb
        - Create branches_from link from trail to parentCrumb
        - Create scoped_to link from stash to trail
        - Fetch all links and verify count is 4
        - Query belongs_to links for trail (filter: LinkType + ToID)
        - Query child_of links where ToID is parentCrumb
        - Delete belongs_to link
        - Fetch all links and verify count is 3
        - Query belongs_to links for trail and verify count is 0
    expected:
      state:
        initial_link_count: 4
        belongs_to_for_trail: 1
        children_of_parent: 1
        final_link_count: 3
        belongs_to_after_delete: 0

cleanup:
  - Remove temp data directory
  - Detach cupboard
