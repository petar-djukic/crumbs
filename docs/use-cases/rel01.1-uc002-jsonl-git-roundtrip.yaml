id: rel01.1-uc002-jsonl-git-roundtrip
title: JSONL Git Roundtrip
summary: |
  A user creates crumbs, commits the JSONL files to git, deletes the SQLite
  database, re-attaches the cupboard, and verifies that all data is intact.
  This validates that JSONL files are the source of truth and that the SQLite
  backend rebuilds state correctly from JSONL on attach.
actor: Developer or coding agent working in a git repository with cupboard data
trigger: Any scenario where the SQLite database is missing or stale, such as cloning a repository, switching branches, or recovering from a corrupted database
flow:
  - F1: "Initialize cupboard in git repository: create data directory, config, and .gitignore"
    detail: |
      mkdir -p /tmp/jsonl-roundtrip-demo
      cd /tmp/jsonl-roundtrip-demo
      git init
      mkdir -p data
      cat > config.yaml <<EOF
      backend: sqlite
      data_dir: ./data
      EOF
      echo "data/cupboard.db" >> .gitignore
      export CUPBOARD_CONFIG=/tmp/jsonl-roundtrip-demo/config.yaml

      The .gitignore excludes cupboard.db per eng01-git-integration: JSONL files
      are committed, SQLite database is ephemeral.
  - F2: "Create crumbs using the cupboard CLI"
    detail: |
      cupboard create --type task --title "First task" --description "Initial work item" --json
      cupboard create --type epic --title "Epic one" --description "Parent work" --labels "code,infra" --json
      cupboard create --type task --title "Second task" --description "Follow-up work" --json

      Each cupboard create calls Table.Set("", crumb) which generates a UUID v7
      (prd-cupboard-core R8), persists to SQLite, and writes to JSONL atomically
      (prd-sqlite-backend R5.2). The immediate sync strategy ensures JSONL files
      are current after every write (prd-sqlite-backend R16.2).
  - F3: "Verify JSONL files exist and contain the data"
    detail: |
      ls -la data/
      cat data/crumbs.jsonl
      wc -l data/crumbs.jsonl

      Expected: Three lines in crumbs.jsonl, one JSON object per crumb. The JSONL
      format follows prd-sqlite-backend R2: one JSON object per line, RFC 3339
      timestamps, lowercase hyphenated UUIDs.
  - F4: "Commit the JSONL files to git"
    detail: |
      git add config.yaml .gitignore
      git add data/*.jsonl
      git commit -m "Add initial cupboard data"

      Per eng01-git-integration, JSONL files are the source of truth and are
      committed to git. The SQLite database is gitignored and regenerated from
      JSONL on every Attach.
  - F5: "Verify SQLite database exists (pre-deletion baseline)"
    detail: |
      ls data/cupboard.db
      cupboard list --json | jq length

      Expected: File exists, output is 3.
  - F6: "Delete SQLite database to simulate fresh clone or branch switch"
    detail: |
      rm data/cupboard.db

      This simulates what happens when a developer clones the repository (only
      JSONL files are in git) or switches to a branch with different data. The
      SQLite database is ephemeral and not version-controlled.
  - F7: "Re-attach by running a cupboard command"
    detail: |
      cupboard list --json | jq length

      Expected: 3. On attach, the SQLite backend performs the startup sequence
      (prd-sqlite-backend R4): creates cupboard.db with schema (R4.3, R4.4),
      loads each JSONL file into the corresponding SQLite table (R4.5), validates
      foreign key relationships (R4.6), returns a ready Cupboard instance (R4.7).
  - F8: "Verify all crumbs are intact"
    detail: |
      cupboard show $TASK1_ID
      cupboard show $EPIC_ID
      cupboard show $TASK2_ID

      Each cupboard show calls Table.Get(id) which queries SQLite (now rebuilt
      from JSONL) and hydrates the row into a Crumb entity (prd-sqlite-backend R14).
  - F9: "Verify queries work correctly"
    detail: |
      cupboard ready --json --type task
      cupboard ready --json --type epic

      Table.Fetch with filter queries the rebuilt SQLite database
      (prd-crumbs-interface R9, R10).
  - F10: "Modify data and verify JSONL is updated"
    detail: |
      cupboard update $TASK1_ID --status in_progress
      cat data/crumbs.jsonl | grep $TASK1_ID
      cupboard close $TASK1_ID
      cat data/crumbs.jsonl | grep $TASK1_ID

      Writes update SQLite first, then persist atomically to JSONL
      (prd-sqlite-backend R5.1, R5.2).
  - F11: "Commit the updated JSONL files"
    detail: |
      git add data/*.jsonl
      git commit -m "Close first task"
      git log --oneline

      Per eng01-git-integration, JSONL changes are committed alongside code
      changes, enabling traceability between task state and commit history.
  - F12: "Repeat the roundtrip: delete database, re-attach, verify"
    detail: |
      rm data/cupboard.db
      cupboard show $TASK1_ID
      cupboard ready --json --type task

      Confirms the roundtrip works for modified data as well as initial data.
      Expected: TASK1_ID shows closed state, ready returns only TASK2_ID.
  - F13: "Test on_close sync strategy: verify JSONL deferred until Detach"
    detail: |
      # Configure SQLiteConfig with SyncStrategy: "on_close"
      config := types.Config{
          Backend: "sqlite",
          DataDir: "/tmp/on-close-test",
          SQLiteConfig: &types.SQLiteConfig{
              SyncStrategy: "on_close",
          },
      }
      cupboard.Attach(config)

      # Create crumbs - SQLite updated, JSONL NOT updated yet
      crumbsTable.Set("", &types.Crumb{Name: "Deferred crumb"})

      # Verify JSONL is empty (writes deferred)
      cat data/crumbs.jsonl | wc -l  # Expected: 0

      # Detach triggers flush
      cupboard.Detach()

      # Now JSONL has the data
      cat data/crumbs.jsonl | wc -l  # Expected: 1

      Per prd-sqlite-backend R16.3, on_close strategy defers all JSONL writes
      until Detach. SQLite remains the write cache during the session.
  - F14: "Test batch sync strategy: verify flush at BatchSize threshold"
    detail: |
      # Configure SQLiteConfig with SyncStrategy: "batch", BatchSize: 5
      config := types.Config{
          Backend: "sqlite",
          DataDir: "/tmp/batch-test",
          SQLiteConfig: &types.SQLiteConfig{
              SyncStrategy: "batch",
              BatchSize:    5,
          },
      }
      cupboard.Attach(config)

      # Create 4 crumbs - no flush yet (below threshold)
      for i := 0; i < 4; i++ {
          crumbsTable.Set("", &types.Crumb{Name: fmt.Sprintf("Crumb %d", i)})
      }
      cat data/crumbs.jsonl | wc -l  # Expected: 0

      # Create 5th crumb - triggers batch flush
      crumbsTable.Set("", &types.Crumb{Name: "Crumb 5"})
      cat data/crumbs.jsonl | wc -l  # Expected: 5

      Per prd-sqlite-backend R16.4, batch strategy flushes when BatchSize
      writes have accumulated.
  - F15: "Test immediate sync strategy (default): verify every write persists"
    detail: |
      # Default config (no SQLiteConfig or SyncStrategy: "immediate")
      config := types.Config{
          Backend: "sqlite",
          DataDir: "/tmp/immediate-test",
      }
      cupboard.Attach(config)

      # Create crumb - immediately persisted
      crumbsTable.Set("", &types.Crumb{Name: "Immediate crumb"})
      cat data/crumbs.jsonl | wc -l  # Expected: 1

      # Create another - also immediately persisted
      crumbsTable.Set("", &types.Crumb{Name: "Another crumb"})
      cat data/crumbs.jsonl | wc -l  # Expected: 2

      Per prd-sqlite-backend R16.2, immediate strategy (default) persists
      every write to JSONL immediately after SQLite commit.
touchpoints:
  - T1: "SQLite backend startup sequence: delete db, create schema, load JSONL (prd-sqlite-backend R4)"
  - T2: "SQLite backend JSONL as source of truth: cupboard.db is ephemeral (prd-sqlite-backend R1.2)"
  - T3: "SQLite backend atomic write pattern for JSONL (prd-sqlite-backend R5.2)"
  - T4: "SQLite backend immediate sync strategy (prd-sqlite-backend R16.2)"
  - T5: "SQLite backend entity hydration from SQLite rows (prd-sqlite-backend R14)"
  - T6: "Cupboard interface: Attach initializes backend (prd-cupboard-core R4)"
  - T7: "Git integration: JSONL files committed, cupboard.db gitignored (eng01-git-integration)"
  - T8: "Git integration: Commit JSONL alongside code changes (eng01-git-integration)"
  - T9: "SQLite backend on_close sync strategy: defer writes until Detach (prd-sqlite-backend R16.3)"
  - T10: "SQLite backend batch sync strategy: flush at BatchSize or BatchInterval (prd-sqlite-backend R16.4-R16.6)"
  - T11: "SQLite backend sync strategy dispatch: backend reads SyncStrategy from config (prd-sqlite-backend R16.1)"
success_criteria:
  - S1: git init and .gitignore setup completes with cupboard.db gitignored
  - S2: cupboard create produces crumbs with JSON output including crumb_id
  - S3: cat data/crumbs.jsonl shows one crumb per line
  - S4: ls data/cupboard.db confirms SQLite database exists
  - S5: git add data/*.jsonl and git commit succeeds with JSONL files tracked
  - S6: rm data/cupboard.db successfully deletes database
  - S7: cupboard list after database deletion returns correct count (data intact)
  - S8: cupboard show after rebuild displays correct title, state, and type
  - S9: ls data/cupboard.db confirms database regenerated on attach
  - S10: cupboard update persists state changes to JSONL
  - S11: State changes survive additional database deletion and rebuild cycles
  - S12: on_close strategy defers all JSONL writes until Detach
  - S13: batch strategy flushes at BatchSize threshold
  - S14: immediate strategy (default) persists every write immediately
out_of_scope:
  - Merge conflict resolution when JSONL files diverge between branches (eng01-git-integration describes this but not validated here)
  - Trail-scoped worktrees (eng01-git-integration Trails as Worktrees)
  - Corrupt JSONL recovery (prd-sqlite-backend R7 describes error handling but this use case assumes valid files)
  - Cross-process access (prd-sqlite-backend R8.5 explicitly does not support this)
  - Batch interval timer edge cases (rapid attach/detach cycles, timer races)
test_suite: test-rel01.1-uc002-jsonl-git-roundtrip
dependencies:
  - D1: "SQLite backend with JSONL persistence (prd-sqlite-backend R1-R5)"
  - D2: "Startup sequence loads JSONL into SQLite (prd-sqlite-backend R4)"
  - D3: "Cupboard interface with Attach/Detach (prd-cupboard-core R4, R5)"
  - D4: "Table interface with Get/Set/Fetch (prd-cupboard-core R3)"
  - D5: "Issue-tracking CLI commands (rel02.1-uc001-issue-tracking-cli)"
risks:
  - K1: "JSONL write fails silently, SQLite ahead of JSONL | Immediate sync strategy writes JSONL on every commit; next attach reconciles from JSONL (prd-sqlite-backend R5.4)"
  - K2: "JSONL files grow unbounded | JSONL uses stable insertion order; rows update in place, new rows append (eng01-git-integration)"
  - K3: "User commits cupboard.db by mistake | .gitignore template and eng01-git-integration documentation prevent this"
  - K4: "JSONL format changes break old files | Unknown fields are ignored (prd-sqlite-backend R7.2); forward compatibility maintained"
demo: |
  # Initialize repository
  mkdir -p /tmp/jsonl-demo && cd /tmp/jsonl-demo
  git init && mkdir data
  echo "data/cupboard.db" >> .gitignore

  # Create crumb
  cupboard create --type task --title "Test" --json
  cat data/crumbs.jsonl | wc -l  # Output: 1

  # Commit JSONL
  git add data/*.jsonl && git commit -m "Add crumb"

  # Delete database and verify roundtrip
  rm data/cupboard.db
  cupboard list --json | jq length  # Output: 1 (data intact)

  # Verify database regenerated
  ls data/cupboard.db  # File exists
references:
  - prd-sqlite-backend
  - prd-cupboard-core
  - eng01-git-integration
  - docs/ARCHITECTURE.md
