id: test-rel03.0-uc003-stash-operations
title: Stash operations for all stash types
description: >
  Validates stash creation for all five stash types (resource, artifact, context,
  counter, lock), value operations (SetValue/GetValue), counter operations (Increment),
  lock operations (Acquire/Release) including reentrant and contention semantics,
  version tracking across mutations, and filtering through the Table interface.
traces:
  - rel03.0-uc003-stash-operations
tags:
  - integration
  - stashes
  - coordination

preconditions:
  - Cupboard initialized with SQLite backend
  - stashes table accessible via GetTable
  - No existing stashes in the database

test_cases:

  # --- S1: Stash created via Table.Set generates UUID v7 for StashID ---

  - name: Create stash generates UUID v7
    inputs:
      command: |
        stash := &Stash{Name: "test-stash", StashType: "context", Value: map[string]any{"key": "value"}, Version: 1}
        id, err := stashesTable.Set("", stash)
    expected:
      exit_code: 0
      state:
        id_not_empty: true
        stash_id_is_uuid_v7: true
        stash_stashid_equals_returned_id: true
        created_at_not_zero: true

  - name: Set with existing ID updates stash
    inputs:
      setup:
        - 'Create context stash with value {"original": true}'
      command: |
        stash.Value = map[string]any{"updated": true}
        stashesTable.Set(stashID, stash)
        entity, _ := stashesTable.Get(stashID)
    expected:
      exit_code: 0
      state:
        value_has_updated_key: true

  # --- S2: All five stash types can be created ---

  - name: Create resource stash
    inputs:
      command: |
        stash := &Stash{Name: "api-connection", StashType: "resource", Value: map[string]any{"uri": "https://api.example.com", "kind": "http"}, Version: 1}
        id, _ := stashesTable.Set("", stash)
        entity, _ := stashesTable.Get(id)
    expected:
      exit_code: 0
      state:
        stash_type: resource

  - name: Create artifact stash
    inputs:
      command: |
        stash := &Stash{Name: "build-output", StashType: "artifact", Value: map[string]any{"path": "/tmp/build.zip", "producer": "build-agent"}, Version: 1}
        id, _ := stashesTable.Set("", stash)
        entity, _ := stashesTable.Get(id)
    expected:
      exit_code: 0
      state:
        stash_type: artifact

  - name: Create context stash
    inputs:
      command: |
        stash := &Stash{Name: "shared-config", StashType: "context", Value: map[string]any{"timeout": 30, "retries": 3}, Version: 1}
        id, _ := stashesTable.Set("", stash)
        entity, _ := stashesTable.Get(id)
    expected:
      exit_code: 0
      state:
        stash_type: context

  - name: Create counter stash
    inputs:
      command: |
        stash := &Stash{Name: "request-counter", StashType: "counter", Value: map[string]any{"value": int64(0)}, Version: 1}
        id, _ := stashesTable.Set("", stash)
        entity, _ := stashesTable.Get(id)
    expected:
      exit_code: 0
      state:
        stash_type: counter

  - name: Create lock stash
    inputs:
      command: |
        stash := &Stash{Name: "resource-lock", StashType: "lock", Value: nil, Version: 1}
        id, _ := stashesTable.Set("", stash)
        entity, _ := stashesTable.Get(id)
    expected:
      exit_code: 0
      state:
        stash_type: lock
        value_is_nil: true

  # --- S3: SetValue updates value and increments Version ---

  - name: SetValue updates value and increments version
    inputs:
      setup:
        - 'Create context stash with value {"timeout": 30} and Version 1'
      command: |
        stash.SetValue(map[string]any{"timeout": 60})
        stashesTable.Set(stashID, stash)
        entity, _ := stashesTable.Get(stashID)
    expected:
      exit_code: 0
      state:
        value_timeout: 60
        version: 2

  - name: SetValue on lock type returns ErrInvalidStashType
    inputs:
      setup:
        - Create lock stash
      command: 'stash.SetValue(map[string]any{"invalid": true})'
    expected:
      error: ErrInvalidStashType

  # --- S4: GetValue returns current value ---

  - name: GetValue returns current value
    inputs:
      setup:
        - 'Create context stash with value {"key": "original"}'
      command: value := stash.GetValue()
    expected:
      state:
        value_not_nil: true
        value_key: original

  - name: GetValue returns nil for empty stash
    inputs:
      setup:
        - Create lock stash with nil value
      command: value := stash.GetValue()
    expected:
      state:
        value_is_nil: true

  # --- S5, S6: Increment adds delta to counter value ---

  - name: Increment with positive delta
    inputs:
      setup:
        - Create counter stash with value 0
      command: |
        newVal, err := stash.Increment(5)
        stashesTable.Set(stashID, stash)
    expected:
      exit_code: 0
      state:
        new_value: 5
        version: 2

  - name: Increment with negative delta
    inputs:
      setup:
        - Create counter stash with value 10
      command: |
        newVal, err := stash.Increment(-3)
        stashesTable.Set(stashID, stash)
    expected:
      exit_code: 0
      state:
        new_value: 7

  - name: Multiple increments accumulate correctly
    inputs:
      setup:
        - Create counter stash with value 0
      command: |
        stash.Increment(10)  // returns 10
        stash.Increment(-3)  // returns 7
        stash.Increment(5)   // returns 12
        stashesTable.Set(stashID, stash)
    expected:
      state:
        final_value: 12
        version: 4

  - name: Increment on non-counter returns ErrInvalidStashType
    inputs:
      setup:
        - Create context stash
      command: stash.Increment(1)
    expected:
      error: ErrInvalidStashType

  # --- S7, S8, S9: Lock operations ---

  - name: Acquire lock sets holder and increments version
    inputs:
      setup:
        - Create lock stash with nil value and Version 1
      command: |
        err := stash.Acquire("worker-1")
        stashesTable.Set(stashID, stash)
    expected:
      exit_code: 0
      state:
        holder: worker-1
        acquired_at_set: true
        version: 2

  - name: Acquire by same holder succeeds (reentrant)
    inputs:
      setup:
        - Create lock stash
        - Acquire lock with holder "worker-1"
      command: stash.Acquire("worker-1")
    expected:
      exit_code: 0
      state:
        holder: worker-1

  - name: Acquire by different holder returns ErrLockHeld
    inputs:
      setup:
        - Create lock stash
        - Acquire lock with holder "worker-1"
      command: stash.Acquire("worker-2")
    expected:
      error: ErrLockHeld

  - name: Acquire with empty holder returns ErrInvalidHolder
    inputs:
      setup:
        - Create lock stash
      command: stash.Acquire("")
    expected:
      error: ErrInvalidHolder

  - name: Acquire on non-lock returns ErrInvalidStashType
    inputs:
      setup:
        - Create context stash
      command: stash.Acquire("worker-1")
    expected:
      error: ErrInvalidStashType

  - name: Release lock clears value and increments version
    inputs:
      setup:
        - Create lock stash
        - Acquire lock with holder "worker-1"
      command: |
        versionAfterAcquire := stash.Version
        err := stash.Release("worker-1")
        stashesTable.Set(stashID, stash)
    expected:
      exit_code: 0
      state:
        value_is_nil: true
        version_incremented: true

  - name: Release by wrong holder returns ErrNotLockHolder
    inputs:
      setup:
        - Create lock stash
        - Acquire lock with holder "worker-1"
      command: stash.Release("worker-2")
    expected:
      error: ErrNotLockHolder

  - name: Release on unheld lock returns ErrNotLockHolder
    inputs:
      setup:
        - Create lock stash with nil value
      command: stash.Release("worker-1")
    expected:
      error: ErrNotLockHolder

  - name: Release on non-lock returns ErrInvalidStashType
    inputs:
      setup:
        - Create context stash
      command: stash.Release("worker-1")
    expected:
      error: ErrInvalidStashType

  # --- S10: Version tracking ---

  - name: Version starts at 1 on creation
    inputs:
      command: |
        stash := &Stash{Name: "version-test", StashType: "context", Value: map[string]any{}, Version: 1}
        stashID, _ := stashesTable.Set("", stash)
        entity, _ := stashesTable.Get(stashID)
    expected:
      state:
        version: 1

  - name: Version increments on each mutation
    inputs:
      setup:
        - Create counter stash with Version 1
      command: |
        stash.Increment(1)
        stash.Increment(1)
        stash.Increment(1)
        stashesTable.Set(stashID, stash)
        entity, _ := stashesTable.Get(stashID)
    expected:
      state:
        version: 4

  # --- S11, S12: Fetch with filters ---

  - name: Fetch by stash_type returns only matching stashes
    inputs:
      setup:
        - Create counter stash "counter-1"
        - Create context stash "context-1"
        - Create lock stash "lock-1"
      command: |
        filter := map[string]any{"StashType": "counter"}
        entities, _ := stashesTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 1
        all_results_type: counter

  - name: Fetch by name returns matching stash
    inputs:
      setup:
        - Create context stash "shared-config"
        - Create context stash "other-config"
      command: |
        filter := map[string]any{"Name": "shared-config"}
        entities, _ := stashesTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 1
        result_name: shared-config

  - name: Fetch with no filter returns all stashes
    inputs:
      setup:
        - Create one stash of each type (resource, artifact, context, counter, lock)
      command: entities, _ := stashesTable.Fetch(nil)
    expected:
      exit_code: 0
      state:
        result_count: 5

  - name: Fetch with no matches returns empty slice
    inputs:
      setup:
        - Create context stash
      command: |
        filter := map[string]any{"StashType": "nonexistent"}
        entities, _ := stashesTable.Fetch(filter)
    expected:
      exit_code: 0
      state:
        result_count: 0

  # --- S13: Delete stash ---

  - name: Delete stash removes it
    inputs:
      setup:
        - Create context stash
      command: |
        err := stashesTable.Delete(stashID)
        _, getErr := stashesTable.Get(stashID)
    expected:
      state:
        delete_succeeds: true
        get_error: ErrNotFound

  - name: Delete nonexistent stash returns ErrNotFound
    inputs:
      command: stashesTable.Delete("nonexistent-uuid-12345")
    expected:
      error: ErrNotFound

  - name: Delete with empty ID returns ErrInvalidID
    inputs:
      command: stashesTable.Delete("")
    expected:
      error: ErrInvalidID

  # --- Additional edge cases ---

  - name: Get with empty ID returns ErrInvalidID
    inputs:
      command: stashesTable.Get("")
    expected:
      error: ErrInvalidID

  - name: Get nonexistent stash returns ErrNotFound
    inputs:
      command: stashesTable.Get("nonexistent-uuid-12345")
    expected:
      error: ErrNotFound

  - name: Fetch on empty table returns empty slice
    inputs:
      command: entities, _ := stashesTable.Fetch(nil)
    expected:
      exit_code: 0
      state:
        result_count: 0

  # --- S14, S15: History tracking ---

  - name: History entry created for each mutation
    description: Verify that stash history is recorded for each operation
    inputs:
      setup:
        - Create context stash
        - SetValue once
        - SetValue again
      command: |
        stashesTable := backend.GetTable("stashes").(*sqlite.Table)
        history, err := stashesTable.FetchStashHistory(stashID)
    expected:
      exit_code: 0
      state:
        history_entry_count: 3
        operations: ["create", "set", "set"]

  - name: History entries queryable by stash ID
    description: Verify FetchStashHistory returns entries ordered by version
    inputs:
      setup:
        - Create counter stash with value 0
        - Increment by 5
        - Increment by 3
      command: |
        stashesTable := backend.GetTable("stashes").(*sqlite.Table)
        history, err := stashesTable.FetchStashHistory(stashID)
    expected:
      exit_code: 0
      state:
        history_entry_count: 3
        operations: ["create", "increment", "increment"]
        versions: [1, 2, 3]
        ordered_by_version_asc: true

  - name: History records operation details
    description: Verify history entries contain version, value, operation, and timestamps
    inputs:
      setup:
        - Create counter stash with value 0
        - Increment by 10
      command: |
        stashesTable := backend.GetTable("stashes").(*sqlite.Table)
        history, err := stashesTable.FetchStashHistory(stashID)
    expected:
      exit_code: 0
      state:
        entry_0_operation: create
        entry_0_version: 1
        entry_1_operation: increment
        entry_1_version: 2
        entry_1_value_counter: 10
        all_entries_have_created_at: true

  # --- Full workflow test ---

  - name: Full stash operations workflow
    description: >
      Create stashes of each type, exercise type-specific operations,
      verify version tracking, filter queries, and cleanup.
    inputs:
      steps:
        - Create resource stash "api-conn" with uri "https://api.example.com"
        - Create artifact stash "build-out" with path "/tmp/build"
        - Create context stash "shared-cfg" with timeout 30
        - Create counter stash "req-counter" with value 0
        - Create lock stash "mutex" with nil value
        - Verify 5 stashes exist via Fetch(nil)
        - SetValue on context stash to update timeout to 60
        - Increment counter by 10, then -3, then 5 (expect 12)
        - Acquire lock with worker-1
        - Try acquire with worker-2 (expect ErrLockHeld)
        - Release lock with worker-1
        - Acquire lock with worker-2 (success)
        - Verify lock holder is worker-2
        - Fetch by stash_type "counter" (expect 1)
        - Fetch by stash_type "lock" (expect 1)
        - Delete context stash
        - Fetch all (expect 4)
    expected:
      state:
        initial_stash_count: 5
        context_value_after_set: 60
        counter_value_after_increments: 12
        lock_holder_after_release_reacquire: worker-2
        counter_fetch_count: 1
        lock_fetch_count: 1
        final_stash_count: 4

cleanup:
  - Remove temp data directory
  - Detach cupboard
