# PRD: Metadata Interface

## Problem

Applications need to attach supplementary information to crumbs beyond structured properties. A developer might add comments during work, attach log files for debugging, or link to external resources. Properties handle typed, single-value attributes; metadata handles unstructured, multi-value content like comments, attachments, and activity logs.

Hardcoding metadata types (comments table, attachments table) creates rigid schemas. Applications should be able to define new metadata types through schema registration without code changes. A plugin might add "reviews" or "time_entries" as new metadata types.

prd-cupboard-core defines the Cupboard interface with uniform Table access, but it does not specify the Metadata entity structure or how metadata interacts with the Table interface. This PRD defines the Metadata entity: the struct fields, schema registration for extensible metadata tables, and how metadata is stored and retrieved via the Table interface.

## Goals

1. Define the Metadata struct with all required fields
2. Define the Schema struct for metadata table schema registration
3. Specify how metadata is created, stored, and queried via the Table interface
4. Define filter conventions for querying metadata
5. Document built-in metadata schemas (comments, attachments)
6. Specify schema registration for custom metadata types
7. Document error conditions for metadata operations

## Requirements

### R1: Metadata Struct

1.1. The Metadata struct must include these fields:

| Field | Type | Description |
|-------|------|-------------|
| MetadataID | string | UUID v7, generated on creation |
| CrumbID | string | The crumb this metadata is attached to |
| TableName | string | The schema this entry belongs to (e.g., "comments") |
| Content | string | The metadata content (text or JSON) |
| PropertyID | *string | Optional property ID for property-specific metadata |
| CreatedAt | time.Time | Timestamp of creation |

1.2. MetadataID must be a UUID v7 (time-ordered) generated by the backend when Table.Set is called with an empty MetadataID.

1.3. CrumbID links the metadata to a specific crumb. The crumb must exist; Table.Set validates this.

1.4. TableName identifies which schema the entry belongs to. Only registered schema names are valid.

1.5. PropertyID is optional. When set, the metadata is associated with a specific property on the crumb (e.g., a comment about the priority value). If provided, the property must exist.

1.6. Content stores the actual metadata. For simple metadata like comments, this is plain text. For structured metadata, this may be JSON.

### R2: Schema Struct

2.1. The Schema struct defines a metadata schema:

| Field | Type | Description |
|-------|------|-------------|
| SchemaName | string | Unique name for this schema (e.g., "comments") |
| Description | string | Optional explanation of the schema's purpose |
| ContentType | string | Expected content format: "text" or "json" |

2.2. SchemaName must be unique across all registered schemas.

2.3. SchemaName must be non-empty and contain only lowercase letters, numbers, and underscores.

2.4. ContentType hints at how Content should be interpreted. "text" means plain text; "json" means JSON-formatted content. The backend does not validate content against this type; it is advisory.

2.5. Schema is intentionally minimal. The metadata system stores flexible content; schema describes intent, not strict structure.

### R3: Built-in Schemas

3.1. The backend must pre-register these built-in metadata schemas on startup:

| SchemaName | ContentType | Description |
|------------|-------------|-------------|
| comments | text | User comments and notes on crumbs |
| attachments | json | File attachments with name, path, and mime type |

3.2. Built-in schemas are always available; applications do not need to register them.

3.3. Built-in schemas cannot be unregistered or modified.

3.4. Comments schema stores plain text comments. Each new metadata entry creates a new comment.

3.5. Attachments schema stores JSON objects describing file attachments:

```json
{
  "name": "screenshot.png",
  "path": "/attachments/01945a3f.png",
  "mime_type": "image/png",
  "size_bytes": 102400
}
```

3.6. The attachments content format is advisory; the backend stores the JSON as-is without validation.

### R4: Creating Metadata

4.1. To create a new metadata entry, the caller constructs a Metadata struct and passes it to Table.Set:

```go
metadata := &Metadata{
    CrumbID:   "crumb-uuid",
    TableName: "comments",
    Content:   "This is a comment",
}
id, err := table.Set("", metadata)
```

4.2. When Table.Set is called with an empty ID, the backend must:

- Generate a UUID v7 for MetadataID
- Set CreatedAt to now
- Validate that TableName is a registered schema (return ErrSchemaNotFound if not)
- Validate that CrumbID references an existing crumb (return ErrNotFound if not)
- Validate that Content is non-empty (return ErrInvalidContent if empty)
- If PropertyID is set, validate that the property exists (return ErrPropertyNotFound if not)

4.3. Validation in 4.2 is atomic: if any validation fails, the metadata is not created.

4.4. After successful creation, the Metadata struct is updated with the generated MetadataID and timestamp.

4.5. Multiple metadata entries can be added to the same crumb for the same schema. Comments are additive, not replacements.

### R5: Retrieving Metadata

5.1. To retrieve a metadata entry by ID, use Table.Get:

```go
entity, err := table.Get(id)
if err != nil {
    // handle error
}
metadata := entity.(*Metadata)
```

5.2. Table.Get returns the entity as any; the caller must type-assert to *Metadata.

5.3. Table.Get returns ErrNotFound if no metadata exists with the given ID.

5.4. Table.Get returns ErrInvalidID if id is empty.

### R6: Metadata Lifecycle

6.1. Metadata entries are append-only by convention. There is no intended Update operation; new entries add context rather than replace old entries.

6.2. Table.Set with an existing MetadataID is technically permitted but discouraged. The backend updates the record if called.

6.3. Table.Delete removes a metadata entry by ID. This is intended for cleanup scenarios, not normal use.

6.4. Table.Delete returns ErrNotFound if no metadata exists with the given ID.

6.5. When a crumb is deleted (via the crumbs table), all its metadata entries must also be deleted (cascading delete).

6.6. Metadata entries cannot be moved between crumbs; CrumbID is immutable after creation.

### R7: Filter Map

7.1. Filters are expressed as map[string]any where keys are filter names and values are filter criteria:

```go
type Filter = map[string]any
```

7.2. Supported filter keys for metadata:

| Key | Value Type | Description |
| --- | ---------- | ----------- |
| "schema" | string | Match entries with this TableName |
| "crumb_id" | string | Match entries for this crumb |
| "property_id" | string | Match entries for this property |
| "content_contains" | string | Match entries where Content contains this substring (case-insensitive) |
| "limit" | int | Maximum results (omit or 0 for no limit) |
| "offset" | int | Skip this many results |

7.3. An empty or nil filter matches all metadata entries.

7.4. Multiple filter keys are ANDed: a metadata entry must match all specified criteria.

7.5. Unknown filter keys must be ignored (forward compatibility).

7.6. Results are ordered by CreatedAt ascending (oldest first) by default.

### R8: Querying Metadata

8.1. To query metadata, use Table.Fetch with a filter map:

```go
filter := map[string]any{
    "schema":   "comments",
    "crumb_id": "crumb-uuid",
    "limit":    50,
}
entities, err := table.Fetch(filter)
```

8.2. Table.Fetch returns a slice of entities ([]any); the caller must type-assert each element to *Metadata:

```go
entries := make([]*Metadata, len(entities))
for i, entity := range entities {
    entries[i] = entity.(*Metadata)
}
```

8.3. Table.Fetch returns an empty slice (not nil) if no metadata entries match.

8.4. Table.Fetch applies limit and offset after filtering and ordering.

8.5. Table.Fetch does not return an error for an empty result set.

8.6. Table.Fetch returns ErrInvalidFilter if a filter value has the wrong type.

### R9: Schema Registration

9.1. Applications can register custom schemas beyond the built-in schemas. Schema registration is handled separately from the metadata Table interface.

9.2. The Cupboard must provide a schema registration mechanism. Implementations may:

- Expose a RegisterSchema method on the Cupboard
- Use a dedicated schemas table where schemas are persisted as entities
- Pre-load schemas from configuration

9.3. Schema registration must validate:

- SchemaName is non-empty and valid format (lowercase, numbers, underscores only)
- SchemaName is unique (not already registered)

9.4. Registration returns ErrDuplicateName if the schema name already exists.

9.5. Registration returns ErrInvalidName if the schema name is empty or invalid format.

9.6. Schemas cannot be unregistered once registered. This prevents orphaned metadata entries.

### R10: Error Types

10.1. Metadata operations and Table operations must return these sentinel errors:

| Error | When |
| ----- | ---- |
| ErrNotFound | Metadata ID does not exist (Table.Get, Table.Delete); or CrumbID does not exist (Table.Set) |
| ErrInvalidID | Metadata ID is empty (Table.Get, Table.Delete) |
| ErrSchemaNotFound | TableName is not a registered schema (Table.Set) |
| ErrDuplicateName | Schema name already exists (schema registration) |
| ErrInvalidName | Schema name is empty or invalid format (schema registration) |
| ErrInvalidContent | Content is empty (Table.Set) |
| ErrInvalidFilter | Filter value has wrong type (Table.Fetch) |
| ErrPropertyNotFound | PropertyID does not exist (Table.Set) |
| ErrCupboardDetached | Cupboard has been detached (all Table operations) |

10.2. All errors must be checkable with errors.Is.

## Non-Goals

1. This PRD does not define the Table interface or Cupboard interface. See prd-cupboard-core.

2. This PRD does not define crumb operations. See prd-crumbs-interface.

3. This PRD does not define property definitions. See prd-properties-interface.

4. This PRD does not define file storage for attachments. The attachments schema stores references; actual file handling is outside this scope.

5. This PRD does not define full-text search indexing. The content_contains filter is substring matching, not ranked search.

6. This PRD does not define schema enforcement. ContentType is advisory; content is stored as-is.

7. This PRD does not define batch operations for metadata (e.g., bulk add, bulk delete).

## Acceptance Criteria

- [ ] Metadata struct defined with MetadataID, CrumbID, TableName, Content, PropertyID, CreatedAt
- [ ] Schema struct defined with SchemaName, Description, ContentType
- [ ] Built-in schemas documented (comments, attachments)
- [ ] Schema registration approach documented
- [ ] Metadata creation via Table.Set specified (ID generation, validation)
- [ ] Metadata retrieval via Table.Get specified (type assertion to *Metadata)
- [ ] Metadata lifecycle documented (append-only convention, cascading delete)
- [ ] Filter map defined with schema, crumb_id, property_id, content_contains, limit, offset
- [ ] Query via Table.Fetch specified (filter map, type assertion, pagination)
- [ ] Error types documented
- [ ] All requirements numbered and specific
- [ ] File saved at docs/product-requirements/prd-metadata-interface.md

## Constraints

- MetadataID uses UUID v7 for time-ordering and uniqueness
- SchemaName (TableName field) must be lowercase with underscores only
- Content is stored as text; JSON content is not parsed or validated
- All timestamps use time.Time (RFC 3339 in JSON)
- Metadata entries are append-only by convention; Table.Delete is available but discouraged
- Type assertions are required when retrieving entities from Table.Get and Table.Fetch

## References

- prd-cupboard-core (Cupboard interface, Table interface, GetTable method)
- prd-sqlite-backend (JSON format, SQLite schema for metadata)
- prd-crumbs-interface (Crumb struct, cascading delete for metadata)
- prd-properties-interface (Property definitions for property-linked metadata)
