id: prd-crumbs-interface
title: Crumbs Interface
problem: |
  Applications need to create, retrieve, and manage individual work items (crumbs). prd-cupboard-core defines the Cupboard interface with uniform Table access, but it does not specify the Crumb entity structure, entity methods, or how crumbs interact with the Table interface. Without this specification, implementations will make inconsistent decisions about field names, state transitions, and property handling.

  This PRD defines the Crumb entity: the struct fields, entity methods for state management and property access, and how crumbs are stored and retrieved via the Table interface. Trail membership is not stored on the Crumb; the links table (prd-sqlite-backend) handles belongs_to relationships.
goals:
  - G1: Define the Crumb struct with all required fields
  - G2: Define state values and their meaning
  - G3: Define entity methods for state transitions (SetState, Pebble, Dust)
  - G4: Define entity methods for property access (SetProperty, GetProperty, GetProperties, ClearProperty)
  - G5: Specify how crumbs are created, stored, and queried via the Table interface
  - G6: Specify state validation rules for entity methods
  - G7: Document error conditions for entity operations
requirements:
  R1:
    title: Crumb Struct
    items:
      - R1.1: The Crumb struct must include the following fields
        detail: |
          | Field | Type | Description |
          |-------|------|-------------|
          | CrumbID | string | UUID v7, generated on creation |
          | Name | string | Human-readable name (required, non-empty) |
          | State | string | Crumb state (see R2) |
          | CreatedAt | time.Time | Timestamp of creation |
          | UpdatedAt | time.Time | Timestamp of last modification |
          | Properties | map[string]any | Property values (property_id → value) |
      - R1.2: CrumbID must be a UUID v7 (time-ordered) generated by the backend when Table.Set is called with an empty CrumbID
      - R1.3: Name must be non-empty. Entity methods that modify name must validate non-empty
      - R1.4: Trail membership is not a Crumb field. Use the links table (belongs_to link type) to associate crumbs with trails. See prd-sqlite-backend
      - R1.5: CreatedAt and UpdatedAt must be set to the current time on creation. UpdatedAt must be updated on any modification (state change, property change)
      - R1.6: Properties is a map from property_id to value. All defined properties are initialized with type-based defaults on creation (see R3)
  R2:
    title: State Values
    items:
      - R2.1: A crumb must be in exactly one of the following states
        detail: |
          | State | Description |
          |-------|-------------|
          | draft | Being written or rewritten; not yet ready for consideration |
          | pending | Created but not ready for work (e.g., waiting for dependencies) |
          | ready | Available for assignment |
          | taken | Currently being worked on |
          | pebble | Successfully finished (permanent, enduring - like pebbles in the story) |
          | dust | Failed or abandoned (swept away - like crumbs eaten by birds) |
      - R2.2: Initial state on creation is draft
      - R2.3: State transitions are validated by entity methods (see R4). Direct modification of the State field bypasses validation; callers should use entity methods
      - R2.4: State is stored as a string, not an enum, for JSON compatibility
      - "R2.5: The states form a logical progression: draft → pending → ready → taken → pebble (success) or dust (failure/abandonment). Entity methods enforce this progression where appropriate"
  R3:
    title: Creating Crumbs
    items:
      - R3.1: To create a new crumb, the caller constructs a Crumb struct and passes it to Table.Set
        detail: |
          ```go
          crumb := &Crumb{
              Name: "task name",
          }
          id, err := table.Set("", crumb)
          ```
      - R3.2: When Table.Set is called with an empty ID, the backend must generate a UUID v7 for CrumbID, set State to "draft", set CreatedAt to now, set UpdatedAt to now, and initialize Properties map with all defined properties set to their type-based default values (see prd-properties-interface R3.5)
      - "R3.3: Property initialization in 3.2 is atomic with crumb creation: if initialization fails, the crumb is not created"
      - R3.4: Table.Set must validate that Name is non-empty and return ErrInvalidName if empty
      - R3.5: After successful creation, the Crumb struct is updated with the generated CrumbID, timestamps, and initialized Properties
  R4:
    title: State Transition Methods
    items:
      - R4.1: The Crumb struct provides methods for common state transitions
        detail: |
          ```go
          func (c *Crumb) SetState(state string) error
          func (c *Crumb) Pebble() error
          func (c *Crumb) Dust() error
          ```
      - "R4.2: SetState transitions the crumb to the specified state: must validate that state is one of the valid states in R2.1 (return ErrInvalidState if not), must update the State field, must update the UpdatedAt timestamp, is idempotent (setting to the current state succeeds without error)"
      - "R4.3: Pebble transitions the crumb to the pebble state (completed successfully): must validate that the current state is taken (return ErrInvalidTransition if not), must set State to \"pebble\", must update UpdatedAt"
      - "R4.4: Dust transitions the crumb to the dust state (failed or abandoned): can be called from any state, must set State to \"dust\", must update UpdatedAt, is idempotent (dusting an already-dust crumb succeeds without error)"
      - R4.5: After calling any state transition method, the caller must save the crumb with Table.Set to persist the changes
        detail: |
          ```go
          crumb.Pebble()
          _, err := table.Set(crumb.CrumbID, crumb)
          ```
  R5:
    title: Property Methods
    items:
      - R5.1: The Crumb struct provides methods for property access
        detail: |
          ```go
          func (c *Crumb) SetProperty(propertyID string, value any) error
          func (c *Crumb) GetProperty(propertyID string) (any, error)
          func (c *Crumb) GetProperties() map[string]any
          func (c *Crumb) ClearProperty(propertyID string) error
          ```
      - R5.2: SetProperty assigns a value to a property. Must validate that the property exists (return ErrPropertyNotFound if not; requires property definitions lookup), must validate that value matches the property's value_type (return ErrTypeMismatch if not), for categorical properties value must be a valid category_id (return ErrInvalidCategory if not), must update the Properties map, must update the UpdatedAt timestamp
        detail: |
          | value_type | Go type | Example |
          | ---------- | ------- | ------- |
          | text | string | "description text" |
          | integer | int64 | 42 |
          | categorical | string | category_id |
          | list | []string | ["tag1", "tag2"] |
      - R5.3: GetProperty retrieves a single property value. Must return the value from the Properties map. Since all properties are initialized on crumb creation (R3.2), the property always has a value. Must return ErrPropertyNotFound if the property does not exist (not in Properties map)
      - R5.4: GetProperties retrieves all property values. Must return the Properties map. The map contains an entry for every defined property. The map is empty only if no properties are defined
      - "R5.5: ClearProperty resets a property to its type-based default. Must set the property value to the type's default value (see prd-properties-interface R3.5), must not delete the map entry (properties are never unset), must return ErrPropertyNotFound if the property does not exist, is idempotent (clearing a property that already has the default value succeeds without error), must update the UpdatedAt timestamp"
      - R5.6: After calling any property method that modifies state, the caller must save the crumb with Table.Set to persist the changes
        detail: |
          ```go
          crumb.SetProperty("priority", int64(3))
          _, err := table.Set(crumb.CrumbID, crumb)
          ```
      - "R5.7: Property methods that require property definition lookup (SetProperty validation, ClearProperty default lookup) need access to the properties table. Implementations may: pass a PropertyTable reference to the Crumb constructor, provide a Crumb.WithProperties(PropertyTable) method, or defer validation to Table.Set (simpler: validation on persist)"
  R6:
    title: Retrieving Crumbs
    items:
      - R6.1: To retrieve a crumb by ID, use Table.Get
        detail: |
          ```go
          entity, err := table.Get(id)
          if err != nil {
              // handle error
          }
          crumb := entity.(*Crumb)
          ```
      - R6.2: Table.Get returns the entity as any; the caller must type-assert to *Crumb
      - R6.3: Table.Get returns ErrNotFound if no crumb exists with the given ID
      - R6.4: Table.Get returns ErrInvalidID if id is empty
  R7:
    title: Updating Crumbs
    items:
      - R7.1: To update a crumb, retrieve it with Table.Get, modify it with entity methods or direct field access, and save it with Table.Set
        detail: |
          ```go
          entity, _ := table.Get(id)
          crumb := entity.(*Crumb)
          crumb.Name = "new name"
          crumb.UpdatedAt = time.Now()
          _, err := table.Set(id, crumb)
          ```
      - R7.2: Direct field modification (e.g., changing Name) does not automatically update UpdatedAt. The caller must update UpdatedAt manually when modifying fields directly
      - R7.3: Entity methods (SetState, SetProperty, etc.) automatically update UpdatedAt
      - R7.4: Table.Set validates that Name is non-empty and returns ErrInvalidName if empty
  R8:
    title: Deleting Crumbs
    items:
      - R8.1: To soft-delete a crumb, use the Dust entity method and save
        detail: |
          ```go
          entity, _ := table.Get(id)
          crumb := entity.(*Crumb)
          crumb.Dust()
          _, _ = table.Set(id, crumb)
          ```
      - R8.2: To hard-delete a crumb, use Table.Delete
        detail: |
          ```go
          err := table.Delete(id)
          ```
      - "R8.3: Table.Delete removes the crumb record and all associated data: all property values (from Properties map), all metadata for the crumb, all links where the crumb is from_id or to_id (belongs_to, child_of)"
      - R8.4: Table.Delete returns ErrNotFound if no crumb exists with the given ID
      - R8.5: Table.Delete returns ErrInvalidID if id is empty
      - "R8.6: Table.Delete must be atomic: all deletions succeed or none do"
      - R8.7: Dust crumbs remain queryable via Table.Fetch. Applications filter by state to exclude dust crumbs from active views
  R9:
    title: Filter Map
    items:
      - R9.1: Filters are expressed as map[string]any where keys are filter names and values are filter criteria
        detail: |
          ```go
          type Filter = map[string]any
          ```
      - R9.2: Supported filter keys for crumbs
        detail: |
          | Key | Value Type | Description |
          | --- | ---------- | ----------- |
          | "states" | []string | Match any of these states (omit for all) |
          | "trail_id" | string | Match crumbs in this trail (via belongs_to link) |
          | "parent_id" | string | Match crumbs that are children of this crumb (via child_of link) |
          | "properties" | map[string]any | Match crumbs with these property values |
          | "limit" | int | Maximum results (omit or 0 for no limit) |
          | "offset" | int | Skip this many results |
      - R9.3: An empty or nil filter matches all crumbs
      - "R9.4: Multiple filter keys are ANDed: a crumb must match all specified criteria"
      - R9.5: Unknown filter keys must be ignored (forward compatibility)
      - R9.6: Results are ordered by CreatedAt descending (newest first)
  R10:
    title: Querying Crumbs
    items:
      - R10.1: To query crumbs, use Table.Fetch with a filter map
        detail: |
          ```go
          filter := map[string]any{
              "states": []string{"ready", "taken"},
              "trail_id": "trail-uuid",
              "limit": 50,
          }
          entities, err := table.Fetch(filter)
          ```
      - R10.2: Table.Fetch returns a slice of entities ([]any); the caller must type-assert each element to *Crumb
        detail: |
          ```go
          crumbs := make([]*Crumb, len(entities))
          for i, entity := range entities {
              crumbs[i] = entity.(*Crumb)
          }
          ```
      - R10.3: Table.Fetch returns an empty slice (not nil) if no crumbs match
      - R10.4: Table.Fetch applies limit and offset after filtering and ordering
      - R10.5: Table.Fetch does not return an error for an empty result set
      - R10.6: Table.Fetch returns ErrInvalidFilter if a filter value has the wrong type (e.g., "states" is not []string)
  R11:
    title: Error Types
    items:
      - R11.1: Crumb entity methods and Table operations must return the following sentinel errors
        detail: |
          | Error | When |
          | ----- | ---- |
          | ErrNotFound | Crumb ID does not exist (Table.Get, Table.Delete) |
          | ErrInvalidID | Crumb ID is empty (Table.Get, Table.Set, Table.Delete) |
          | ErrInvalidName | Name is empty (Table.Set) |
          | ErrInvalidState | State value is not recognized (SetState) |
          | ErrInvalidTransition | State transition is not allowed (Pebble requires taken state) |
          | ErrInvalidFilter | Filter value has wrong type (Table.Fetch) |
          | ErrPropertyNotFound | Property ID does not exist (SetProperty, GetProperty, ClearProperty) |
          | ErrInvalidCategory | Category ID is not valid for the property (SetProperty) |
          | ErrTypeMismatch | Value type does not match property value_type (SetProperty) |
          | ErrCupboardDetached | Cupboard has been detached (all Table operations) |
      - R11.2: All errors must be checkable with errors.Is
non_goals:
  - This PRD does not define the Table interface or Cupboard interface. See prd-cupboard-core
  - This PRD does not define trail operations. See prd-trails-interface
  - This PRD does not define property definitions. See prd-properties-interface
  - This PRD does not define complex state transition rules beyond Pebble validation. Applications may add additional validation logic
  - This PRD does not define batch operations (e.g., bulk dust, bulk update)
  - This PRD does not define full-text search on crumb names or content
  - This PRD does not define property validation at the entity method level. Property methods may defer validation to Table.Set for simplicity
acceptance_criteria:
  - Crumb struct defined with CrumbID, Name, State, CreatedAt, UpdatedAt, Properties fields
  - State values documented (draft, pending, ready, taken, pebble, dust)
  - State transition methods defined (SetState, Pebble, Dust)
  - State transition validation rules documented (Pebble requires taken state)
  - Property methods defined (SetProperty, GetProperty, GetProperties, ClearProperty)
  - Property method behavior documented (validation, defaults, UpdatedAt)
  - Crumb creation via Table.Set specified (ID generation, state initialization, property initialization)
  - Crumb retrieval via Table.Get specified (type assertion to *Crumb)
  - Crumb update pattern documented (Get, modify, Set)
  - Crumb deletion via Table.Delete specified (hard delete, cascade)
  - Soft delete via Dust method documented
  - Filter map defined with states, trail_id, parent_id, properties, limit, offset
  - Query via Table.Fetch specified (filter map, type assertion, pagination)
  - Error types documented (including ErrInvalidTransition)
  - All requirements numbered and specific
constraints:
  - CrumbID uses UUID v7 for time-ordering and uniqueness
  - Property values are stored as JSON-compatible types in the Properties map
  - State is a string for JSON serialization (not a Go enum)
  - All timestamps use time.Time (RFC 3339 in JSON)
  - Filter uses map[string]any for flexibility; backends translate to queries
  - Entity methods update struct fields in memory; caller must call Table.Set to persist changes
  - Type assertions are required when retrieving entities from Table.Get and Table.Fetch
references:
  - prd-cupboard-core (Cupboard interface, Table interface, GetTable method)
  - prd-sqlite-backend (JSON format, SQLite schema, links table)
  - prd-trails-interface (trail operations, belongs_to relationship)
  - prd-properties-interface (property definitions, value types, type-based defaults)
