# PRD: Stash Interface

## Problem

Crumbs are individual work items. Trails group them. But there is no mechanism for crumbs to share runtime state. When multiple agents coordinate on related tasks, they need shared resources (files, URLs, connections), artifacts (outputs from one crumb as inputs to another), context (decisions, configuration), and coordination primitives (locks, counters).

Without shared state, agents must pass information through external channels or encode it in crumb properties, which conflates task attributes with coordination state. We need a dedicated entity for shared state that is scoped to a trail (or global), versioned, and auditable.

This PRD defines the StashTable interface: the Stash and StashHistory structs, stash types, CRUD operations, type-specific operations, and history operations.

## Goals

1. Define the Stash struct with all required fields
2. Define the StashHistory struct for change tracking
3. Define stash types and their semantics
4. Specify CRUD operations (Create, Get, GetByName, List, Delete)
5. Specify value operations (Set, GetValue)
6. Specify counter operations (Increment)
7. Specify lock operations (Acquire, Release, TryAcquire)
8. Specify history operations (GetHistory, GetValueAtVersion)
9. Document error conditions for all operations

## Requirements

### R1: Stash Struct

1.1. The Stash struct must include these fields:

| Field | Type | Description |
|-------|------|-------------|
| StashID | string | UUID v7, generated on creation |
| TrailID | *string | Trail scope; null for global stashes |
| Name | string | Human-readable name, unique within scope |
| StashType | string | Type of stash (see R3) |
| Value | any | Current value (JSON blob) |
| Version | int64 | Monotonically increasing version number |
| CreatedAt | time.Time | Timestamp of creation |
| UpdatedAt | time.Time | Timestamp of last modification |

1.2. StashID must be a UUID v7 (time-ordered) generated by the backend on Create.

1.3. TrailID is optional. When null, the stash is global (accessible from any trail). When set, the stash is scoped to that trail.

1.4. Name must be unique within scope. For trail-scoped stashes, name must be unique within that trail. For global stashes, name must be unique among global stashes. Create must reject duplicate names with ErrDuplicateName.

1.5. Name must be non-empty. Create must reject empty names with ErrInvalidName.

1.6. Version starts at 1 on creation and increments on every mutation. Version is never reset.

1.7. Value is stored as a JSON blob. The structure depends on StashType (see R3).

### R2: StashHistory Struct

2.1. The StashHistory struct must include these fields:

| Field | Type | Description |
|-------|------|-------------|
| HistoryID | string | UUID v7, generated on each change |
| StashID | string | The stash this history entry belongs to |
| Version | int64 | The version number after this change |
| Value | any | The value after this change |
| Operation | string | The operation that caused this change |
| ChangedBy | *string | Crumb ID that made the change (nullable) |
| CreatedAt | time.Time | Timestamp of this change |

2.2. HistoryID must be a UUID v7 (time-ordered) generated by the backend on each mutation.

2.3. Every mutation to a stash creates a history entry. History is append-only and immutable.

2.4. Operation values correspond to the operation that caused the change:

| Operation | When |
|-----------|------|
| create | Stash was created |
| set | Value was set via Set operation |
| increment | Counter was incremented |
| acquire | Lock was acquired |
| release | Lock was released |

2.5. ChangedBy is the crumb ID that initiated the change. It may be null for operations not associated with a specific crumb (e.g., administrative changes).

### R3: Stash Types

3.1. A stash must have exactly one of these types:

| StashType | Purpose | Value Schema |
|-----------|---------|--------------|
| resource | External resources | `{"uri": string, "kind": string, ...}` |
| artifact | Work outputs | `{"path": string, "producer": string, "checksum": string, ...}` |
| context | Shared configuration | `{...arbitrary key-value pairs...}` |
| counter | Atomic numeric state | `{"value": int64}` |
| lock | Mutual exclusion | `{"holder": string, "acquired_at": timestamp}` or `null` |

3.2. StashType is stored as a string for JSON compatibility.

3.3. Type-specific operations (R9, R10) validate that the stash has the correct type.

### R4: Create Operation

4.1. Create creates a new stash:

```go
func (t StashTable) Create(trailID *string, name, stashType string, initialValue any) (*Stash, error)
```

4.2. Create must generate a UUID v7 for StashID.

4.3. Create must set Version to 1, CreatedAt to now, and UpdatedAt to now.

4.4. Create must validate that name is non-empty (ErrInvalidName if empty).

4.5. Create must validate that name is unique within scope (ErrDuplicateName if exists).

4.6. Create must validate that stashType is one of the valid types in R3.1 (ErrInvalidStashType if not).

4.7. Create must validate that initialValue matches the expected schema for the stash type.

4.8. Create must persist the stash before returning.

4.9. Create must record a history entry with operation "create".

4.10. Create must return the created Stash with all fields populated.

4.11. For lock type, initialValue should be null (unlocked). For counter type, initialValue should be `{"value": 0}` or a specified starting value.

### R5: Get Operation

5.1. Get retrieves a stash by ID:

```go
func (t StashTable) Get(id string) (*Stash, error)
```

5.2. Get must return the Stash if found.

5.3. Get must return ErrNotFound if no stash exists with the given ID.

5.4. Get must return ErrInvalidID if id is empty.

### R6: GetByName Operation

6.1. GetByName retrieves a stash by name within a scope:

```go
func (t StashTable) GetByName(trailID *string, name string) (*Stash, error)
```

6.2. If trailID is nil, search global stashes. If trailID is set, search stashes scoped to that trail.

6.3. GetByName must return the Stash if found.

6.4. GetByName must return ErrNotFound if no stash exists with the given name in the scope.

6.5. GetByName must return ErrInvalidName if name is empty.

### R7: List Operation

7.1. List retrieves all stashes in a scope:

```go
func (t StashTable) List(trailID *string) ([]*Stash, error)
```

7.2. If trailID is nil, return global stashes. If trailID is set, return stashes scoped to that trail.

7.3. List must return an empty slice (not nil) if no stashes exist in the scope.

7.4. Results are ordered by CreatedAt ascending (oldest first).

### R8: Delete Operation

8.1. Delete permanently removes a stash and all its history:

```go
func (t StashTable) Delete(id string) error
```

8.2. Delete must remove the stash record.

8.3. Delete must remove all history entries for the stash.

8.4. Delete must return ErrNotFound if no stash exists with the given ID.

8.5. Delete must return ErrInvalidID if id is empty.

8.6. Delete must return ErrLockHeld if the stash is a lock and is currently held.

8.7. Delete must be atomic: all deletions succeed or none do.

### R9: Set Operation

9.1. Set updates the value of a stash:

```go
func (t StashTable) Set(id string, value any, changedBy *string) error
```

9.2. Set must validate that the stash exists (ErrNotFound if not).

9.3. Set must validate that value matches the expected schema for the stash type.

9.4. Set must increment Version.

9.5. Set must update UpdatedAt to now.

9.6. Set must record a history entry with operation "set".

9.7. Set must return ErrInvalidStashType if called on a lock-type stash (use Acquire/Release instead).

### R10: GetValue Operation

10.1. GetValue retrieves the current value of a stash:

```go
func (t StashTable) GetValue(id string) (any, error)
```

10.2. GetValue must return the value if the stash exists.

10.3. GetValue must return ErrNotFound if no stash exists with the given ID.

10.4. GetValue must return ErrInvalidID if id is empty.

### R11: Counter Operations

11.1. Increment atomically adds to a counter stash:

```go
func (t StashTable) Increment(id string, delta int64, changedBy *string) (int64, error)
```

11.2. Increment must validate that the stash exists (ErrNotFound if not).

11.3. Increment must validate that the stash type is "counter" (ErrInvalidStashType if not).

11.4. Increment must atomically add delta to the counter value and return the new value.

11.5. Delta may be negative (decrement).

11.6. Increment must increment Version.

11.7. Increment must update UpdatedAt to now.

11.8. Increment must record a history entry with operation "increment".

### R12: Lock Operations

12.1. Acquire obtains a lock:

```go
func (t StashTable) Acquire(id string, holder string, timeout time.Duration) error
```

12.2. Acquire must validate that the stash exists (ErrNotFound if not).

12.3. Acquire must validate that the stash type is "lock" (ErrInvalidStashType if not).

12.4. If the lock is not held (value is null), Acquire must set value to `{"holder": holder, "acquired_at": now}`.

12.5. If the lock is held by another holder, Acquire must wait up to timeout for the lock to be released. If timeout elapses, return ErrLockTimeout.

12.6. If the lock is already held by the same holder, Acquire succeeds (reentrant).

12.7. Acquire must increment Version.

12.8. Acquire must update UpdatedAt to now.

12.9. Acquire must record a history entry with operation "acquire".

12.10. Holder must be non-empty. Acquire must return ErrInvalidHolder if holder is empty.

12.11. Release releases a lock:

```go
func (t StashTable) Release(id string, holder string) error
```

12.12. Release must validate that the stash exists (ErrNotFound if not).

12.13. Release must validate that the stash type is "lock" (ErrInvalidStashType if not).

12.14. Release must validate that the lock is held by the specified holder (ErrNotLockHolder if not).

12.15. Release must set value to null (unlocked).

12.16. Release must increment Version.

12.17. Release must update UpdatedAt to now.

12.18. Release must record a history entry with operation "release".

12.19. TryAcquire attempts to obtain a lock without waiting:

```go
func (t StashTable) TryAcquire(id string, holder string) (bool, error)
```

12.20. TryAcquire must validate that the stash exists (ErrNotFound if not).

12.21. TryAcquire must validate that the stash type is "lock" (ErrInvalidStashType if not).

12.22. If the lock is not held, TryAcquire must acquire it and return true.

12.23. If the lock is held by the same holder, TryAcquire must return true (reentrant).

12.24. If the lock is held by another holder, TryAcquire must return false without waiting.

### R13: History Operations

13.1. GetHistory retrieves the change history for a stash:

```go
func (t StashTable) GetHistory(id string, limit, offset int) ([]*StashHistoryEntry, error)
```

13.2. GetHistory must return history entries ordered by Version descending (newest first).

13.3. GetHistory must return ErrNotFound if no stash exists with the given ID.

13.4. GetHistory must return ErrInvalidID if id is empty.

13.5. If limit is 0, return all history entries. If limit is positive, return at most that many entries.

13.6. Offset specifies how many entries to skip (for pagination).

13.7. GetValueAtVersion retrieves the value at a specific version:

```go
func (t StashTable) GetValueAtVersion(id string, version int64) (any, error)
```

13.8. GetValueAtVersion must return the value recorded in the history entry for that version.

13.9. GetValueAtVersion must return ErrNotFound if the stash does not exist.

13.10. GetValueAtVersion must return ErrVersionNotFound if no history entry exists for that version.

### R14: Error Types

14.1. StashTable operations must return these sentinel errors:

| Error | When |
|-------|------|
| ErrNotFound | Stash ID does not exist |
| ErrInvalidID | Stash ID is empty |
| ErrInvalidName | Name is empty |
| ErrDuplicateName | Name already exists in scope |
| ErrInvalidStashType | StashType is not recognized or operation invalid for type |
| ErrLockHeld | Cannot delete a lock that is held |
| ErrLockTimeout | Acquire timed out waiting for lock |
| ErrNotLockHolder | Release called by non-holder |
| ErrInvalidHolder | Holder string is empty |
| ErrVersionNotFound | History version does not exist |
| ErrCupboardClosed | Cupboard has been closed |

14.2. All errors must be checkable with errors.Is.

## Non-Goals

1. This PRD does not define queue or channel stash types. These may be added in a future version.

2. This PRD does not define stash replication or cross-cupboard sharing.

3. This PRD does not define TTL or automatic expiration for stashes.

4. This PRD does not define access control or permissions on stashes.

5. This PRD does not define history compaction or pruning. History grows unbounded.

## Acceptance Criteria

- [ ] Stash struct defined with StashID, TrailID, Name, StashType, Value, Version, CreatedAt, UpdatedAt
- [ ] StashHistory struct defined with HistoryID, StashID, Version, Value, Operation, ChangedBy, CreatedAt
- [ ] Stash types documented (resource, artifact, context, counter, lock)
- [ ] Create operation specified (create stash, validate type, record history)
- [ ] Get and GetByName operations specified (retrieve by ID or name)
- [ ] List operation specified (list stashes in scope)
- [ ] Delete operation specified (remove stash and history)
- [ ] Set operation specified (update value, record history)
- [ ] Counter operations specified (Increment with atomic semantics)
- [ ] Lock operations specified (Acquire, Release, TryAcquire)
- [ ] History operations specified (GetHistory, GetValueAtVersion)
- [ ] Error types documented
- [ ] All requirements numbered and specific
- [ ] File saved at docs/product-requirements/prd-stash-interface.md

## Constraints

- StashID and HistoryID use UUID v7 for time-ordering and uniqueness
- Value is stored as JSON for flexibility
- StashType is a string for JSON serialization (not a Go enum)
- All timestamps use time.Time (RFC 3339 in JSON)
- History is append-only and immutable
- Lock operations must be atomic to prevent race conditions
- Counter increment must be atomic

## References

- prd-cupboard-core (Cupboard interface, StashTable accessor)
- prd-sqlite-backend (JSON format, SQLite schema, stash tables)
- prd-trails-interface (trail scoping for stashes)
