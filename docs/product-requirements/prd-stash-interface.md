# PRD: Stash Interface

## Problem

Crumbs are individual work items. Trails group them. But there is no mechanism for crumbs to share runtime state. When multiple agents coordinate on related tasks, they need shared resources (files, URLs, connections), artifacts (outputs from one crumb as inputs to another), context (decisions, configuration), and coordination primitives (locks, counters).

Without shared state, agents must pass information through external channels or encode it in crumb properties, which conflates task attributes with coordination state. We need a dedicated entity for shared state that is scoped to a trail (or global), versioned, and auditable.

This PRD defines the Stash entity: the struct fields, stash types, entity methods for value management and coordination, and how stashes interact with the Table interface.

## Goals

1. Define the Stash struct with all required fields
2. Define stash types and their semantics
3. Define entity methods for value access (SetValue, GetValue)
4. Define entity methods for counter operations (Increment)
5. Define entity methods for lock operations (Acquire, Release)
6. Define history entry structure for backend tracking
7. Specify how stashes are created, stored, and queried via the Table interface
8. Document error conditions for entity operations

## Requirements

### R1: Stash Struct

1.1. The Stash struct must include these fields:

| Field | Type | Description |
|-------|------|-------------|
| StashID | string | UUID v7, generated on creation |
| Name | string | Human-readable name, unique within scope |
| StashType | string | Type of stash (see R2) |
| Value | any | Current value (JSON blob) |
| Version | int64 | Monotonically increasing version number |
| CreatedAt | time.Time | Timestamp of creation |

1.2. StashID must be a UUID v7 (time-ordered) generated by the backend when Table.Set is called with an empty StashID.

1.3. Stash scope (trail or global) uses the links table with `scoped_to` link type (see R13). Global stashes have no `scoped_to` link.

1.4. Name must be unique within scope. For trail-scoped stashes, name must be unique within that trail. For global stashes, name must be unique among global stashes. Table.Set must reject duplicate names with ErrDuplicateName.

1.5. Name must be non-empty. Table.Set must reject empty names with ErrInvalidName.

1.6. Version starts at 1 on creation and increments on every mutation. Version is never reset.

1.7. Value is stored as a JSON blob. The structure depends on StashType (see R2).

### R2: Stash Types

2.1. A stash must have exactly one of these types:

| StashType | Purpose | Value Schema |
|-----------|---------|--------------|
| resource | External resources | `{"uri": string, "kind": string, ...}` |
| artifact | Work outputs | `{"path": string, "producer": string, "checksum": string, ...}` |
| context | Shared configuration | `{...arbitrary key-value pairs...}` |
| counter | Atomic numeric state | `{"value": int64}` |
| lock | Mutual exclusion | `{"holder": string, "acquired_at": timestamp}` or `null` |

2.2. StashType is stored as a string for JSON compatibility.

2.3. StashType must be one of the valid types in 2.1. Table.Set must reject unrecognized types with ErrInvalidStashType.

2.4. Type-specific entity methods (R5, R6) validate that the stash has the correct type before operating.

### R3: Creating Stashes

3.1. To create a new stash, the caller constructs a Stash struct and passes it to Table.Set:

```go
stash := &Stash{
    Name:      "shared-config",
    StashType: "context",
    Value:     map[string]any{"timeout": 30},
}
err := table.Set("", stash)
```

3.2. When Table.Set is called with an empty ID, the backend must:

- Generate a UUID v7 for StashID
- Set Version to 1
- Set CreatedAt to now
- Validate Name is non-empty (ErrInvalidName if empty)
- Validate Name is unique in scope (ErrDuplicateName if exists)
- Validate StashType is recognized (ErrInvalidStashType if not)
- Record a history entry with operation "create"

3.3. For lock type, initial Value should be nil (unlocked). For counter type, initial Value should be `{"value": 0}` or a specified starting value.

3.4. After successful creation, the Stash struct is updated with the generated StashID, Version, and CreatedAt.

### R4: Value Methods

4.1. The Stash struct provides methods for value access:

```go
func (s *Stash) SetValue(value any) error
func (s *Stash) GetValue() any
```

4.2. SetValue updates the stash value:

- Must increment Version
- Must return ErrInvalidStashType if called on a lock-type stash (use Acquire/Release instead)
- After calling SetValue, the caller must save with Table.Set to persist changes

4.3. GetValue retrieves the current value:

- Returns the Value field
- Returns nil if the stash has no value set

4.4. Example usage:

```go
entity, _ := table.Get(id)
stash := entity.(*Stash)
stash.SetValue(map[string]any{"timeout": 60})
table.Set(stash.StashID, stash)
```

### R5: Counter Operations

5.1. The Stash struct provides a method for counter operations:

```go
func (s *Stash) Increment(delta int64) (int64, error)
```

5.2. Increment atomically adds delta to the counter value:

- Must validate that StashType is "counter" (return ErrInvalidStashType if not)
- Must extract current value from Value field, add delta, and store result
- Must increment Version
- Must return the new counter value
- Delta may be negative (decrement)
- After calling Increment, the caller must save with Table.Set to persist changes

5.3. Example usage:

```go
entity, _ := table.Get(id)
stash := entity.(*Stash)
newVal, err := stash.Increment(1)
table.Set(stash.StashID, stash)
```

### R6: Lock Operations

6.1. The Stash struct provides methods for lock operations:

```go
func (s *Stash) Acquire(holder string) error
func (s *Stash) Release(holder string) error
```

6.2. Acquire obtains the lock:

- Must validate that StashType is "lock" (return ErrInvalidStashType if not)
- Must validate that holder is non-empty (return ErrInvalidHolder if empty)
- If the lock is not held (Value is nil), set Value to `{"holder": holder, "acquired_at": now}`
- If the lock is already held by the same holder, succeed (reentrant)
- If the lock is held by another holder, return ErrLockHeld
- Must increment Version
- After calling Acquire, the caller must save with Table.Set to persist changes

6.3. Release releases the lock:

- Must validate that StashType is "lock" (return ErrInvalidStashType if not)
- Must validate that the lock is held by the specified holder (return ErrNotLockHolder if not)
- Must set Value to nil (unlocked)
- Must increment Version
- After calling Release, the caller must save with Table.Set to persist changes

6.4. Example usage:

```go
entity, _ := table.Get(id)
stash := entity.(*Stash)
err := stash.Acquire("worker-1")
if err == nil {
    table.Set(stash.StashID, stash)
}
// ... do work ...
stash.Release("worker-1")
table.Set(stash.StashID, stash)
```

6.5. Lock operations are non-blocking. For waiting behavior, callers implement retry loops with backoff.

### R7: History Tracking

7.1. The backend maintains a history log of stash mutations. History is backend-managed, not accessed through entity methods.

7.2. StashHistoryEntry contains:

| Field | Type | Description |
|-------|------|-------------|
| HistoryID | string | UUID v7 of the history entry |
| Version | int64 | Version number after this change |
| Value | any | Value after this change |
| Operation | string | Operation that caused this change |
| ChangedBy | *string | Crumb ID that made the change (nullable) |
| CreatedAt | time.Time | Timestamp of this change |

7.3. Operation constants (defined in pkg/types/stash.go):

| Constant | Value | When |
|----------|-------|------|
| StashOpCreate | "create" | Stash was created |
| StashOpSet | "set" | Value was set via SetValue |
| StashOpIncrement | "increment" | Counter was incremented |
| StashOpAcquire | "acquire" | Lock was acquired |
| StashOpRelease | "release" | Lock was released |

7.4. History access is a backend concern. Backends may expose history through:

- A dedicated history query method on the stash table
- Filter parameters on Table.Fetch
- A separate history service

7.5. The StashHistoryEntry struct is defined in pkg/types for backends to use when returning history data.

### R8: Retrieving Stashes

8.1. To retrieve a stash by ID, use Table.Get:

```go
entity, err := table.Get(id)
if err != nil {
    // handle error
}
stash := entity.(*Stash)
```

8.2. Table.Get returns the entity as any; the caller must type-assert to *Stash.

8.3. Table.Get returns ErrNotFound if no stash exists with the given ID.

8.4. Table.Get returns ErrInvalidID if id is empty.

### R9: Filter Map

9.1. Filters are expressed as map[string]any where keys are filter names and values are filter criteria:

```go
type Filter = map[string]any
```

9.2. Supported filter keys for stashes:

| Key | Value Type | Description |
| --- | ---------- | ----------- |
| "stash_type" | string | Match stashes of this type |
| "name" | string | Match stash by name (exact match) |
| "limit" | int | Maximum results (omit or 0 for no limit) |
| "offset" | int | Skip this many results |

9.2.1. To filter by trail scope, applications query the links table for `scoped_to` links and use the resulting stash IDs.

9.3. An empty or nil filter matches all stashes.

9.4. Multiple filter keys are ANDed: a stash must match all specified criteria.

9.5. Unknown filter keys must be ignored (forward compatibility).

9.6. Results are ordered by CreatedAt ascending (oldest first).

### R10: Querying Stashes

10.1. To query stashes, use Table.Fetch with a filter map:

```go
filter := map[string]any{
    "trail_id":   &trailID,
    "stash_type": "lock",
}
entities, err := table.Fetch(filter)
```

10.2. Table.Fetch returns a slice of entities ([]any); the caller must type-assert each element to *Stash:

```go
stashes := make([]*Stash, len(entities))
for i, entity := range entities {
    stashes[i] = entity.(*Stash)
}
```

10.3. Table.Fetch returns an empty slice (not nil) if no stashes match.

### R11: Deleting Stashes

11.1. To delete a stash, use Table.Delete:

```go
err := table.Delete(id)
```

11.2. Table.Delete removes the stash record and all its history.

11.3. Table.Delete returns ErrNotFound if no stash exists with the given ID.

11.4. Table.Delete returns ErrInvalidID if id is empty.

11.5. Table.Delete returns ErrLockHeld if the stash is a lock and is currently held.

11.6. Table.Delete must be atomic: all deletions succeed or none do.

### R12: Error Types

12.1. Stash entity methods and Table operations use sentinel errors defined in pkg/types/table.go:

| Error | When |
|-------|------|
| ErrNotFound | Stash ID does not exist |
| ErrInvalidID | Stash ID is empty |
| ErrInvalidName | Name is empty |
| ErrInvalidStashType | StashType is not recognized or operation invalid for type |
| ErrLockHeld | Cannot delete a lock that is held, or Acquire called on held lock |
| ErrNotLockHolder | Release called by non-holder |
| ErrInvalidHolder | Holder string is empty |
| ErrCupboardDetached | Cupboard has been detached |

12.2. All errors are checkable with errors.Is.

12.3. Backend implementations may return additional errors for validation (e.g., duplicate names) as needed.

### R13: Stash Scoping

13.1. A stash can be scoped to a trail via a `scoped_to` link in the links table:

| Field | Value |
|-------|-------|
| link_type | "scoped_to" |
| from_id | stash_id |
| to_id | trail_id |

13.2. A stash can have at most one `scoped_to` link. The backend must enforce this constraint.

13.3. Stashes without a `scoped_to` link are global (accessible from any trail).

13.4. Stash scoping is managed via the links table. Applications create `scoped_to` links using the Table interface for the links table:

```go
link := &Link{
    LinkType: "scoped_to",
    FromID:   stash.StashID,
    ToID:     trailID,
}
linksTable.Set("", link)
```

13.5. To find which trail a stash is scoped to, query the links table for a `scoped_to` link where `from_id` equals the stash ID.

13.6. To find all stashes scoped to a trail, query the links table for `scoped_to` links where `to_id` equals the trail ID.

## Non-Goals

1. This PRD does not define queue or channel stash types. These may be added in a future version.

2. This PRD does not define stash replication or cross-cupboard sharing.

3. This PRD does not define TTL or automatic expiration for stashes.

4. This PRD does not define access control or permissions on stashes.

5. This PRD does not define history compaction or pruning. History grows unbounded.

6. This PRD does not define blocking lock acquisition with timeout. Callers implement retry loops.

## Acceptance Criteria

- [ ] Stash struct defined with StashID, Name, StashType, Value, Version, CreatedAt fields
- [ ] Stash types documented (resource, artifact, context, counter, lock)
- [ ] Entity methods defined for value access (SetValue, GetValue)
- [ ] Entity methods defined for counter operations (Increment)
- [ ] Entity methods defined for lock operations (Acquire, Release)
- [ ] StashHistoryEntry struct documented for backend history tracking
- [ ] History operation constants documented (create, set, increment, acquire, release)
- [ ] Stash creation via Table.Set specified (ID generation, version initialization)
- [ ] Stash retrieval via Table.Get specified (type assertion to *Stash)
- [ ] Filter map defined with stash_type, name, limit, offset
- [ ] Query via Table.Fetch specified (filter map, type assertion)
- [ ] Stash deletion via Table.Delete specified (cascade to history)
- [ ] Stash scoping semantics documented (scoped_to link, one per stash)
- [ ] Error types documented
- [ ] All requirements numbered and specific
- [ ] File saved at docs/product-requirements/prd-stash-interface.md

## Constraints

- StashID uses UUID v7 for time-ordering and uniqueness
- Value is stored as JSON for flexibility
- StashType is a string for JSON serialization (not a Go enum)
- All timestamps use time.Time (RFC 3339 in JSON)
- History is append-only and immutable
- Lock operations are non-blocking; callers handle waiting
- Entity methods update struct fields in memory; caller must call Table.Set to persist changes
- Type assertions are required when retrieving entities from Table.Get and Table.Fetch
- Stashâ†’trail scope uses the links table with `scoped_to` link type (see ARCHITECTURE Decision 10). Global stashes have no `scoped_to` link. This keeps all relationships in one consistent pattern.

## References

- prd-cupboard-core (Cupboard interface, Table interface, GetTable method)
- prd-sqlite-backend (JSON format, SQLite schema, stash tables)
- prd-trails-interface (trail scoping for stashes)
