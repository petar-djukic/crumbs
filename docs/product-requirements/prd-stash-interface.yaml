id: prd-stash-interface
title: Stash Interface
problem: |
  Crumbs are individual work items. Trails group them. But there is no mechanism for crumbs to share runtime state. When multiple agents coordinate on related tasks, they need shared resources (files, URLs, connections), artifacts (outputs from one crumb as inputs to another), context (decisions, configuration), and coordination primitives (locks, counters).

  Without shared state, agents must pass information through external channels or encode it in crumb properties, which conflates task attributes with coordination state. We need a dedicated entity for shared state that is scoped to a trail (or global), versioned, and auditable.

  This PRD defines the Stash entity: the struct fields, stash types, entity methods for value management and coordination, and how stashes interact with the Table interface.
goals:
  - G1: Define the Stash struct with all required fields
  - G2: Define stash types and their semantics
  - G3: Define entity methods for value access (SetValue, GetValue)
  - G4: Define entity methods for counter operations (Increment)
  - G5: Define entity methods for lock operations (Acquire, Release)
  - G6: Define history entry structure for backend tracking
  - G7: Specify how stashes are created, stored, and queried via the Table interface
  - G8: Document error conditions for entity operations
requirements:
  R1:
    title: Stash Struct
    items:
      - R1.1: The Stash struct must include the following fields
        detail: |
          | Field | Type | Description |
          |-------|------|-------------|
          | StashID | string | UUID v7, generated on creation |
          | Name | string | Human-readable name, unique within scope |
          | StashType | string | Type of stash (see R2) |
          | Value | any | Current value (JSON blob) |
          | Version | int64 | Monotonically increasing version number |
          | CreatedAt | time.Time | Timestamp of creation |
          | LastOperation | string | Most recent mutation operation (see R7.3 for values) |
          | ChangedBy | *string | Who performed the last mutation (optional) |
      - R1.2: StashID must be a UUID v7 (time-ordered) generated by the backend when Table.Set is called with an empty StashID
      - R1.3: Stash scope (trail or global) uses the links table with `scoped_to` link type (see R13). Global stashes have no `scoped_to` link
      - R1.4: Name must be unique within scope. For trail-scoped stashes, name must be unique within that trail. For global stashes, name must be unique among global stashes. Table.Set must reject duplicate names with ErrDuplicateName
      - R1.5: Name must be non-empty. Table.Set must reject empty names with ErrInvalidName
      - R1.6: Version starts at 1 on creation and increments on every mutation. Version is never reset
      - R1.7: Value is stored as a JSON blob. The structure depends on StashType (see R2)
  R2:
    title: Stash Types
    items:
      - R2.1: A stash must have exactly one of the following types
        detail: |
          | StashType | Purpose | Value Schema |
          |-----------|---------|--------------|
          | resource | External resources | `{"uri": string, "kind": string, ...}` |
          | artifact | Work outputs | `{"path": string, "producer": string, "checksum": string, ...}` |
          | context | Shared configuration | `{...arbitrary key-value pairs...}` |
          | counter | Atomic numeric state | `{"value": int64}` |
          | lock | Mutual exclusion | `{"holder": string, "acquired_at": timestamp}` or `null` |
      - R2.2: StashType is stored as a string for JSON compatibility
      - R2.3: StashType must be one of the valid types in 2.1. Table.Set must reject unrecognized types with ErrInvalidStashType
      - R2.4: Type-specific entity methods (R5, R6) validate that the stash has the correct type before operating
  R3:
    title: Creating Stashes
    items:
      - R3.1: To create a new stash, the caller constructs a Stash struct and passes it to Table.Set
        detail: |
          ```go
          stash := &Stash{
              Name:      "shared-config",
              StashType: "context",
              Value:     map[string]any{"timeout": 30},
          }
          err := table.Set("", stash)
          ```
      - R3.2: When Table.Set is called with an empty ID, the backend must generate a UUID v7 for StashID, set Version to 1, set CreatedAt to now, validate Name is non-empty (ErrInvalidName if empty), validate Name is unique in scope (ErrDuplicateName if exists), validate StashType is recognized (ErrInvalidStashType if not), and record a history entry with operation "create"
      - R3.3: For lock type, initial Value should be nil (unlocked). For counter type, initial Value should be `{"value": 0}` or a specified starting value
      - R3.4: After successful creation, the Stash struct is updated with the generated StashID, Version, and CreatedAt
  R4:
    title: Value Methods
    items:
      - R4.1: The Stash struct provides methods for value access
        detail: |
          ```go
          func (s *Stash) SetValue(value any) error
          func (s *Stash) GetValue() any
          ```
      - R4.2: SetValue updates the stash value. Must increment Version. Must return ErrInvalidStashType if called on a lock-type stash (use Acquire/Release instead). After calling SetValue, the caller must save with Table.Set to persist changes
      - "R4.3: GetValue retrieves the current value. Returns the Value field. Returns nil if the stash has no value set"
      - R4.4: Example usage
        detail: |
          ```go
          entity, _ := table.Get(id)
          stash := entity.(*Stash)
          stash.SetValue(map[string]any{"timeout": 60})
          table.Set(stash.StashID, stash)
          ```
  R5:
    title: Counter Operations
    items:
      - R5.1: The Stash struct provides a method for counter operations
        detail: |
          ```go
          func (s *Stash) Increment(delta int64) (int64, error)
          ```
      - R5.2: Increment atomically adds delta to the counter value. Must validate that StashType is "counter" (return ErrInvalidStashType if not). Must extract current value from Value field, add delta, and store result. Must increment Version. Must return the new counter value. Delta may be negative (decrement). After calling Increment, the caller must save with Table.Set to persist changes
      - R5.3: Example usage
        detail: |
          ```go
          entity, _ := table.Get(id)
          stash := entity.(*Stash)
          newVal, err := stash.Increment(1)
          table.Set(stash.StashID, stash)
          ```
  R6:
    title: Lock Operations
    items:
      - R6.1: The Stash struct provides methods for lock operations
        detail: |
          ```go
          func (s *Stash) Acquire(holder string) error
          func (s *Stash) Release(holder string) error
          ```
      - R6.2: Acquire obtains the lock. Must validate that StashType is "lock" (return ErrInvalidStashType if not). Must validate that holder is non-empty (return ErrInvalidHolder if empty). If the lock is not held (Value is nil), set Value to `{"holder": holder, "acquired_at": now}`. If the lock is already held by the same holder, succeed (reentrant). If the lock is held by another holder, return ErrLockHeld. Must increment Version. After calling Acquire, the caller must save with Table.Set to persist changes
      - R6.3: Release releases the lock. Must validate that StashType is "lock" (return ErrInvalidStashType if not). Must validate that the lock is held by the specified holder (return ErrNotLockHolder if not). Must set Value to nil (unlocked). Must increment Version. After calling Release, the caller must save with Table.Set to persist changes
      - R6.4: Example usage
        detail: |
          ```go
          entity, _ := table.Get(id)
          stash := entity.(*Stash)
          err := stash.Acquire("worker-1")
          if err == nil {
              table.Set(stash.StashID, stash)
          }
          // ... do work ...
          stash.Release("worker-1")
          table.Set(stash.StashID, stash)
          ```
      - R6.5: Lock operations are non-blocking. For waiting behavior, callers implement retry loops with backoff
  R7:
    title: History Tracking
    items:
      - R7.1: The backend maintains a history log of stash mutations. History is backend-managed, not accessed through entity methods
      - R7.2: StashHistoryEntry contains the following fields
        detail: |
          | Field | Type | Description |
          |-------|------|-------------|
          | HistoryID | string | UUID v7 of the history entry |
          | StashID | string | ID of the stash this history entry belongs to |
          | Version | int64 | Version number after this change |
          | Value | any | Value after this change |
          | Operation | string | Operation that caused this change |
          | ChangedBy | *string | Crumb ID that made the change (nullable) |
          | CreatedAt | time.Time | Timestamp of this change |
      - R7.3: Operation constants (defined in pkg/types/stash.go)
        detail: |
          | Constant | Value | When |
          |----------|-------|------|
          | StashOpCreate | "create" | Stash was created |
          | StashOpSet | "set" | Value was set via SetValue |
          | StashOpIncrement | "increment" | Counter was incremented |
          | StashOpAcquire | "acquire" | Lock was acquired |
          | StashOpRelease | "release" | Lock was released |
      - "R7.4: History access is a backend concern. Backends may expose history through: a dedicated history query method on the stash table, filter parameters on Table.Fetch, or a separate history service"
      - R7.5: The StashHistoryEntry struct is defined in pkg/types for backends to use when returning history data
      - R7.6: Backend must provide a method to query stash history entries by stash ID, returning entries ordered by version ascending
        detail: |
          The SQLite backend exposes FetchStashHistory(stashID string) on the stashes Table:
          ```go
          stashesTable := cupboard.GetTable("stashes")
          table := stashesTable.(*sqlite.Table)
          history, err := table.FetchStashHistory(stashID)
          ```
          Returns []types.StashHistoryEntry or error. Returns ErrInvalidID if stashID is empty.
          Returns ErrCupboardDetached if the backend is not attached.
  R8:
    title: Retrieving Stashes
    items:
      - R8.1: To retrieve a stash by ID, use Table.Get
        detail: |
          ```go
          entity, err := table.Get(id)
          if err != nil {
              // handle error
          }
          stash := entity.(*Stash)
          ```
      - R8.2: Table.Get returns the entity as any; the caller must type-assert to *Stash
      - R8.3: Table.Get returns ErrNotFound if no stash exists with the given ID
      - R8.4: Table.Get returns ErrInvalidID if id is empty
  R9:
    title: Filter Map
    items:
      - R9.1: Filters are expressed as map[string]any where keys are filter names and values are filter criteria
        detail: |
          ```go
          type Filter = map[string]any
          ```
      - R9.2: Supported filter keys for stashes
        detail: |
          | Key | Value Type | Description |
          | --- | ---------- | ----------- |
          | "stash_type" | string | Match stashes of this type |
          | "name" | string | Match stash by name (exact match) |
          | "limit" | int | Maximum results (omit or 0 for no limit) |
          | "offset" | int | Skip this many results |
      - R9.2.1: To filter by trail scope, applications query the links table for `scoped_to` links and use the resulting stash IDs
      - R9.3: An empty or nil filter matches all stashes
      - "R9.4: Multiple filter keys are ANDed: a stash must match all specified criteria"
      - R9.5: Unknown filter keys must be ignored (forward compatibility)
      - R9.6: Results are ordered by CreatedAt ascending (oldest first)
  R10:
    title: Querying Stashes
    items:
      - R10.1: To query stashes by type, use Table.Fetch with a filter map
        detail: |
          ```go
          // Find all lock-type stashes
          filter := map[string]any{
              "stash_type": "lock",
          }
          entities, err := stashTable.Fetch(filter)
          ```

          To find stashes scoped to a trail, query the links table for `scoped_to` links (per R9.2.1):

          ```go
          // Find stash IDs scoped to a trail
          linkFilter := map[string]any{
              "link_type": "scoped_to",
              "to_id":     trailID,
          }
          links, err := linksTable.Fetch(linkFilter)
          // Extract stash IDs from links (each link.FromID is a stash_id)
          ```
      - R10.2: Table.Fetch returns a slice of entities ([]any); the caller must type-assert each element to *Stash
        detail: |
          ```go
          stashes := make([]*Stash, len(entities))
          for i, entity := range entities {
              stashes[i] = entity.(*Stash)
          }
          ```
      - R10.3: Table.Fetch returns an empty slice (not nil) if no stashes match
  R11:
    title: Deleting Stashes
    items:
      - R11.1: To delete a stash, use Table.Delete
        detail: |
          ```go
          err := table.Delete(id)
          ```
      - R11.2: Table.Delete removes the stash record and all its history
      - R11.3: Table.Delete returns ErrNotFound if no stash exists with the given ID
      - R11.4: Table.Delete returns ErrInvalidID if id is empty
      - R11.5: Table.Delete returns ErrLockHeld if the stash is a lock and is currently held
      - "R11.6: Table.Delete must be atomic: all deletions succeed or none do"
  R12:
    title: Error Types
    items:
      - R12.1: Stash entity methods and Table operations use sentinel errors defined in pkg/types/table.go
        detail: |
          | Error | When |
          |-------|------|
          | ErrNotFound | Stash ID does not exist |
          | ErrInvalidID | Stash ID is empty |
          | ErrInvalidName | Name is empty |
          | ErrInvalidStashType | StashType is not recognized or operation invalid for type |
          | ErrLockHeld | Cannot delete a lock that is held, or Acquire called on held lock |
          | ErrNotLockHolder | Release called by non-holder |
          | ErrInvalidHolder | Holder string is empty |
          | ErrCupboardDetached | Cupboard has been detached |
      - R12.2: All errors are checkable with errors.Is
      - R12.3: Backend implementations may return additional errors for validation (e.g., duplicate names) as needed
  R13:
    title: Stash Scoping
    items:
      - R13.1: A stash can be scoped to a trail via a `scoped_to` link in the links table
        detail: |
          | Field | Value |
          |-------|-------|
          | link_type | "scoped_to" |
          | from_id | stash_id |
          | to_id | trail_id |
      - R13.2: A stash can have at most one `scoped_to` link. The backend must enforce this constraint
      - R13.3: Stashes without a `scoped_to` link are global (accessible from any trail)
      - R13.4: Stash scoping is managed via the links table. Applications create `scoped_to` links using the Table interface for the links table
        detail: |
          ```go
          link := &Link{
              LinkType: "scoped_to",
              FromID:   stash.StashID,
              ToID:     trailID,
          }
          linksTable.Set("", link)
          ```
      - R13.5: To find which trail a stash is scoped to, query the links table for a `scoped_to` link where `from_id` equals the stash ID
      - R13.6: To find all stashes scoped to a trail, query the links table for `scoped_to` links where `to_id` equals the trail ID
non_goals:
  - This PRD does not define queue or channel stash types. These may be added in a future version
  - This PRD does not define stash replication or cross-cupboard sharing
  - This PRD does not define TTL or automatic expiration for stashes
  - This PRD does not define access control or permissions on stashes
  - This PRD does not define history compaction or pruning. History grows unbounded
  - This PRD does not define blocking lock acquisition with timeout. Callers implement retry loops
acceptance_criteria:
  - Stash struct defined with StashID, Name, StashType, Value, Version, CreatedAt fields
  - Stash types documented (resource, artifact, context, counter, lock)
  - Entity methods defined for value access (SetValue, GetValue)
  - Entity methods defined for counter operations (Increment)
  - Entity methods defined for lock operations (Acquire, Release)
  - StashHistoryEntry struct documented for backend history tracking
  - History operation constants documented (create, set, increment, acquire, release)
  - Stash creation via Table.Set specified (ID generation, version initialization)
  - Stash retrieval via Table.Get specified (type assertion to *Stash)
  - Filter map defined with stash_type, name, limit, offset
  - Query via Table.Fetch specified (filter map, type assertion)
  - Stash deletion via Table.Delete specified (cascade to history)
  - Stash scoping semantics documented (scoped_to link, one per stash)
  - Error types documented
  - All requirements numbered and specific
constraints:
  - StashID uses UUID v7 for time-ordering and uniqueness
  - Value is stored as JSON for flexibility
  - StashType is a string for JSON serialization (not a Go enum)
  - All timestamps use time.Time (RFC 3339 in JSON)
  - History is append-only and immutable
  - Lock operations are non-blocking; callers handle waiting
  - Entity methods update struct fields in memory; caller must call Table.Set to persist changes
  - Type assertions are required when retrieving entities from Table.Get and Table.Fetch
  - "Stashâ†’trail scope uses the links table with `scoped_to` link type (see ARCHITECTURE Decision 10). Global stashes have no `scoped_to` link. This keeps all relationships in one consistent pattern"
references:
  - prd-cupboard-core (Cupboard interface, Table interface, GetTable method)
  - prd-sqlite-backend (JSON format, SQLite schema, stash tables)
  - prd-trails-interface (trail scoping for stashes)
