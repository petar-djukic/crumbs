id: prd-metadata-interface
title: Metadata Interface
problem: |
  Applications need to attach supplementary information to crumbs beyond structured properties. A developer might add comments during work, attach log files for debugging, or link to external resources. Properties handle typed, single-value attributes; metadata handles unstructured, multi-value content like comments, attachments, and activity logs.

  Hardcoding metadata types (comments table, attachments table) creates rigid schemas. Applications should be able to define new metadata types through schema registration without code changes. A plugin might add "reviews" or "time_entries" as new metadata types.

  prd-cupboard-core defines the Cupboard interface with uniform Table access, but it does not specify the Metadata entity structure or how metadata interacts with the Table interface. This PRD defines the Metadata entity: the struct fields, schema registration for extensible metadata tables, and how metadata is stored and retrieved via the Table interface.
goals:
  - G1: Define the Metadata struct with all required fields
  - G2: Define the Schema struct for metadata table schema registration
  - G3: Specify how metadata is created, stored, and queried via the Table interface
  - G4: Define filter conventions for querying metadata
  - G5: Document built-in metadata schemas (comments, attachments)
  - G6: Specify schema registration for custom metadata types
  - G7: Document error conditions for metadata operations
requirements:
  R1:
    title: Metadata Struct
    items:
      - R1.1: The Metadata struct must include the fields defined in the following table
        detail: |
          | Field | Type | Description |
          |-------|------|-------------|
          | MetadataID | string | UUID v7, generated on creation |
          | CrumbID | string | The crumb this metadata is attached to |
          | TableName | string | The schema this entry belongs to (e.g., "comments") |
          | Content | string | The metadata content (text or JSON) |
          | PropertyID | *string | Optional property ID for property-specific metadata |
          | CreatedAt | time.Time | Timestamp of creation |
      - R1.2: MetadataID must be a UUID v7 (time-ordered) generated by the backend when Table.Set is called with an empty MetadataID
      - R1.3: CrumbID links the metadata to a specific crumb. The crumb must exist; Table.Set validates this
      - R1.4: TableName identifies which schema the entry belongs to. Only registered schema names are valid
      - R1.5: PropertyID is optional. When set, the metadata is associated with a specific property on the crumb (e.g., a comment about the priority value). If provided, the property must exist
      - R1.6: Content stores the actual metadata. For simple metadata like comments, this is plain text. For structured metadata, this may be JSON
  R2:
    title: Schema Struct
    items:
      - R2.1: The Schema struct defines a metadata schema
        detail: |
          | Field | Type | Description |
          |-------|------|-------------|
          | SchemaName | string | Unique name for this schema (e.g., "comments") |
          | Description | string | Optional explanation of the schema's purpose |
          | ContentType | string | Expected content format: "text" or "json" |
      - R2.2: SchemaName must be unique across all registered schemas
      - R2.3: SchemaName must be non-empty and contain only lowercase letters, numbers, and underscores
      - R2.4: ContentType hints at how Content should be interpreted. "text" means plain text; "json" means JSON-formatted content. The backend does not validate content against this type; it is advisory
      - R2.5: Schema is intentionally minimal. The metadata system stores flexible content; schema describes intent, not strict structure
  R3:
    title: Built-in Schemas
    items:
      - R3.1: The backend must pre-register the built-in metadata schemas on startup
        detail: |
          | SchemaName | ContentType | Description |
          |------------|-------------|-------------|
          | comments | text | User comments and notes on crumbs |
          | attachments | json | File attachments with name, path, and mime type |
      - R3.2: Built-in schemas are always available; applications do not need to register them
      - R3.3: Built-in schemas cannot be unregistered or modified
      - R3.4: Comments schema stores plain text comments. Each new metadata entry creates a new comment
      - R3.5: Attachments schema stores JSON objects describing file attachments
        detail: |
          ```json
          {
            "name": "screenshot.png",
            "path": "/attachments/01945a3f.png",
            "mime_type": "image/png",
            "size_bytes": 102400
          }
          ```
      - R3.6: The attachments content format is advisory; the backend stores the JSON as-is without validation
  R4:
    title: Creating Metadata
    items:
      - R4.1: To create a new metadata entry, the caller constructs a Metadata struct and passes it to Table.Set
        detail: |
          ```go
          metadata := &Metadata{
              CrumbID:   "crumb-uuid",
              TableName: "comments",
              Content:   "This is a comment",
          }
          id, err := table.Set("", metadata)
          ```
      - R4.2: "When Table.Set is called with an empty ID, the backend must: generate a UUID v7 for MetadataID; set CreatedAt to now; validate that TableName is a registered schema (return ErrSchemaNotFound if not); validate that CrumbID references an existing crumb (return ErrNotFound if not); validate that Content is non-empty (return ErrInvalidContent if empty); if PropertyID is set, validate that the property exists (return ErrPropertyNotFound if not)"
      - R4.3: "Validation in R4.2 is atomic: if any validation fails, the metadata is not created"
      - R4.4: After successful creation, the Metadata struct is updated with the generated MetadataID and timestamp
      - R4.5: Multiple metadata entries can be added to the same crumb for the same schema. Comments are additive, not replacements
  R5:
    title: Retrieving Metadata
    items:
      - R5.1: To retrieve a metadata entry by ID, use Table.Get
        detail: |
          ```go
          entity, err := table.Get(id)
          if err != nil {
              // handle error
          }
          metadata := entity.(*Metadata)
          ```
      - R5.2: Table.Get returns the entity as any; the caller must type-assert to *Metadata
      - R5.3: Table.Get returns ErrNotFound if no metadata exists with the given ID
      - R5.4: Table.Get returns ErrInvalidID if id is empty
  R6:
    title: Metadata Lifecycle
    items:
      - R6.1: Metadata entries are append-only by convention. There is no intended Update operation; new entries add context rather than replace old entries
      - R6.2: Table.Set with an existing MetadataID is technically permitted but discouraged. The backend updates the record if called
      - R6.3: Table.Delete removes a metadata entry by ID. This is intended for cleanup scenarios, not normal use
      - R6.4: Table.Delete returns ErrNotFound if no metadata exists with the given ID
      - R6.5: When a crumb is deleted (via the crumbs table), all its metadata entries must also be deleted (cascading delete)
      - R6.6: Metadata entries cannot be moved between crumbs; CrumbID is immutable after creation
  R7:
    title: Filter Map
    items:
      - R7.1: Filters are expressed as map[string]any where keys are filter names and values are filter criteria
        detail: |
          ```go
          type Filter = map[string]any
          ```
      - R7.2: Supported filter keys for metadata are defined in the following table
        detail: |
          | Key | Value Type | Description |
          | --- | ---------- | ----------- |
          | "schema" | string | Match entries with this TableName |
          | "crumb_id" | string | Match entries for this crumb |
          | "property_id" | string | Match entries for this property |
          | "content_contains" | string | Match entries where Content contains this substring (case-insensitive) |
          | "limit" | int | Maximum results (omit or 0 for no limit) |
          | "offset" | int | Skip this many results |
      - R7.3: An empty or nil filter matches all metadata entries
      - R7.4: "Multiple filter keys are ANDed: a metadata entry must match all specified criteria"
      - R7.5: Unknown filter keys must be ignored (forward compatibility)
      - R7.6: Results are ordered by CreatedAt ascending (oldest first) by default
  R8:
    title: Querying Metadata
    items:
      - R8.1: To query metadata, use Table.Fetch with a filter map
        detail: |
          ```go
          filter := map[string]any{
              "schema":   "comments",
              "crumb_id": "crumb-uuid",
              "limit":    50,
          }
          entities, err := table.Fetch(filter)
          ```
      - R8.2: Table.Fetch returns a slice of entities ([]any); the caller must type-assert each element to *Metadata
        detail: |
          ```go
          entries := make([]*Metadata, len(entities))
          for i, entity := range entities {
              entries[i] = entity.(*Metadata)
          }
          ```
      - R8.3: Table.Fetch returns an empty slice (not nil) if no metadata entries match
      - R8.4: Table.Fetch applies limit and offset after filtering and ordering
      - R8.5: Table.Fetch does not return an error for an empty result set
      - R8.6: Table.Fetch returns ErrInvalidFilter if a filter value has the wrong type
  R9:
    title: Schema Registration
    items:
      - R9.1: Applications can register custom schemas beyond the built-in schemas. Schema registration is handled separately from the metadata Table interface
      - R9.2: "The Cupboard must provide a schema registration mechanism. Implementations may: expose a RegisterSchema method on the Cupboard; use a dedicated schemas table where schemas are persisted as entities; pre-load schemas from configuration"
      - R9.3: "Schema registration must validate: SchemaName is non-empty and valid format (lowercase, numbers, underscores only); SchemaName is unique (not already registered)"
      - R9.4: Registration returns ErrDuplicateName if the schema name already exists
      - R9.5: Registration returns ErrInvalidName if the schema name is empty or invalid format
      - R9.6: Schemas cannot be unregistered once registered. This prevents orphaned metadata entries
  R10:
    title: Error Types
    items:
      - R10.1: Metadata operations and Table operations must return the sentinel errors defined in the following table
        detail: |
          | Error | When |
          | ----- | ---- |
          | ErrNotFound | Metadata ID does not exist (Table.Get, Table.Delete); or CrumbID does not exist (Table.Set) |
          | ErrInvalidID | Metadata ID is empty (Table.Get, Table.Delete) |
          | ErrSchemaNotFound | TableName is not a registered schema (Table.Set) |
          | ErrDuplicateName | Schema name already exists (schema registration) |
          | ErrInvalidName | Schema name is empty or invalid format (schema registration) |
          | ErrInvalidContent | Content is empty (Table.Set) |
          | ErrInvalidFilter | Filter value has wrong type (Table.Fetch) |
          | ErrPropertyNotFound | PropertyID does not exist (Table.Set) |
          | ErrCupboardDetached | Cupboard has been detached (all Table operations) |
      - R10.2: All errors must be checkable with errors.Is
non_goals:
  - This PRD does not define the Table interface or Cupboard interface. See prd-cupboard-core.
  - This PRD does not define crumb operations. See prd-crumbs-interface.
  - This PRD does not define property definitions. See prd-properties-interface.
  - This PRD does not define file storage for attachments. The attachments schema stores references; actual file handling is outside this scope.
  - This PRD does not define full-text search indexing. The content_contains filter is substring matching, not ranked search.
  - This PRD does not define schema enforcement. ContentType is advisory; content is stored as-is.
  - This PRD does not define batch operations for metadata (e.g., bulk add, bulk delete).
acceptance_criteria:
  - Metadata struct defined with MetadataID, CrumbID, TableName, Content, PropertyID, CreatedAt
  - Schema struct defined with SchemaName, Description, ContentType
  - Built-in schemas documented (comments, attachments)
  - Schema registration approach documented
  - Metadata creation via Table.Set specified (ID generation, validation)
  - Metadata retrieval via Table.Get specified (type assertion to *Metadata)
  - Metadata lifecycle documented (append-only convention, cascading delete)
  - Filter map defined with schema, crumb_id, property_id, content_contains, limit, offset
  - Query via Table.Fetch specified (filter map, type assertion, pagination)
  - Error types documented
  - All requirements numbered and specific
constraints:
  - MetadataID uses UUID v7 for time-ordering and uniqueness
  - SchemaName (TableName field) must be lowercase with underscores only
  - Content is stored as text; JSON content is not parsed or validated
  - All timestamps use time.Time (RFC 3339 in JSON)
  - Metadata entries are append-only by convention; Table.Delete is available but discouraged
  - Type assertions are required when retrieving entities from Table.Get and Table.Fetch
references:
  - prd-cupboard-core (Cupboard interface, Table interface, GetTable method)
  - prd-sqlite-backend (JSON format, SQLite schema for metadata)
  - prd-crumbs-interface (Crumb struct, cascading delete for metadata)
  - prd-properties-interface (Property definitions for property-linked metadata)
