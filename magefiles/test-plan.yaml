id: test-mage-reset-lifecycle
title: Mage init/reset target isolation and orchestration
traces:
  - eng02-generation-workflow

preconditions:
  - On main branch with clean working tree
  - bd CLI available on PATH
  - mage available (go/bin/mage or PATH)

test_cases:

  # ── 1. Individual reset targets (independence) ──

  - name: cobbler:reset only removes .cobbler/
    inputs:
      setup:
        - mkdir -p .cobbler && echo test > .cobbler/dummy.json
        - mage beads:init
      command: mage cobbler:reset
    expected:
      exit_code: 0
      state:
        cobbler_dir_exists: false
        beads_dir_exists: true
        generation_branches: unchanged

  - name: beads:reset only touches .beads/
    inputs:
      setup:
        - mage beads:init
        - mkdir -p .cobbler && echo test > .cobbler/dummy.json
      command: mage beads:reset
    expected:
      exit_code: 0
      state:
        beads_dir_exists: true
        beads_issues_empty: true
        cobbler_file_exists: true

  - name: beads:reset does not resurrect issues
    inputs:
      setup:
        - mage beads:init
        - bd create --type task --json "Dummy task" --description "Should not survive reset"
        - bd list --json
      command: mage beads:reset
    expected:
      exit_code: 0
      state:
        beads_issues_empty: true
      stdout_not_contains: "Dummy task"

  - name: generator:reset only touches branches and Go sources
    inputs:
      setup:
        - mage generator:start
        - mkdir -p .cobbler && echo test > .cobbler/dummy.json
      command: mage generator:reset
    expected:
      exit_code: 0
      state:
        current_branch: main
        generation_branches: none
        go_sources_seeded: true
        cobbler_file_exists: true

  # ── 2. Top-level orchestrators ──

  - name: init is idempotent
    inputs:
      setup:
        - rm -rf .beads/
      commands:
        - mage init
        - mage init
    expected:
      exit_code: 0
      state:
        beads_dir_exists: true
      stdout_contains: "already initialized"

  - name: init creates beads from scratch
    inputs:
      setup:
        - rm -rf .beads/
      command: mage init
    expected:
      exit_code: 0
      state:
        beads_dir_exists: true

  - name: reset wipes all artifact types
    inputs:
      setup:
        - mage generator:start
        - mkdir -p .cobbler && echo test > .cobbler/dummy.json
      command: mage reset
    expected:
      exit_code: 0
      state:
        cobbler_dir_exists: false
        current_branch: main
        generation_branches: none
        go_sources_seeded: true
        beads_dir_exists: true
        beads_issues_empty: true

  - name: reset ordering (generator before beads)
    description: >
      generator:reset commits a clean-state commit. beads:reset commits
      empty JSONL. Verify the git log shows the generator commit before
      the beads commit.
    inputs:
      setup:
        - mage generator:start
      command: mage reset
    expected:
      exit_code: 0
      git_log_order:
        - "Reset beads"
        - "Generator reset"

  # ── 3. Edge cases ──

  - name: cobbler:reset when .cobbler/ does not exist
    inputs:
      setup:
        - rm -rf .cobbler/
      command: mage cobbler:reset
    expected:
      exit_code: 0

  - name: beads:reset when .beads/ does not exist
    inputs:
      setup:
        - rm -rf .beads/
      command: mage beads:reset
    expected:
      exit_code: 0

  - name: generator:reset when already on main with no branches
    inputs:
      setup: []
      command: mage generator:reset
    expected:
      exit_code: 0
      state:
        current_branch: main
        go_sources_seeded: true

  - name: reset from fully clean state
    inputs:
      setup:
        - rm -rf .cobbler/ .beads/
      command: mage reset
    expected:
      exit_code: 0

  # ── 4. Build and test targets ──

  - name: build succeeds without container runtime
    inputs:
      command: mage build
    expected:
      exit_code: 0
      stderr_contains: "skipping image build"
      state:
        binary_exists: bin/cupboard

  - name: lint passes on clean codebase
    inputs:
      command: mage lint
    expected:
      exit_code: 0

  - name: test:unit runs without test files
    inputs:
      command: mage test:unit
    expected:
      exit_code: 0
      stdout_contains: "no test files"

  - name: test:integration skips when tests/ directory is missing
    inputs:
      setup:
        - rm -rf tests/
      command: mage test:integration
    expected:
      exit_code: 0
      stdout_contains: "No integration test directory found"

  - name: test:all succeeds with no test files
    inputs:
      command: mage test:all
    expected:
      exit_code: 0

  - name: install copies binary to GOPATH/bin
    inputs:
      command: mage install
    expected:
      exit_code: 0

  - name: clean removes build artifacts
    inputs:
      setup:
        - mage build
      command: mage clean
    expected:
      exit_code: 0
      state:
        binary_exists: false

  - name: stats outputs JSON with expected fields
    inputs:
      command: mage stats
    expected:
      exit_code: 0
      stdout_json:
        go_loc: integer
        go_loc_prod: integer
        go_loc_test: integer
        spec_wc_prd: integer
        spec_wc_test: integer
        spec_wc_uc: integer

  # ── 5. Cobbler integration (requires Claude CLI) ──

  - name: cobbler:measure respects --no-container
    description: >
      Ignore the exit code; Claude may fail if no API key is configured.
      The test only checks that the --no-container flag routes to the
      direct execution path by inspecting the stderr message printed
      before Claude is invoked.
    inputs:
      setup:
        - mage beads:init
      command: mage cobbler:measure --no-container --max-issues 1 --silence-agent=false
    expected:
      exit_code: ignored
      stderr_contains: "Running Claude (direct)"
      stderr_not_contains: "Running Claude (podman)"

  - name: cobbler:measure creates issues and reset clears them
    description: >
      End-to-end: measure proposes one issue, verify it exists in beads,
      then reset beads and verify it is gone. Confirms the full
      measure-to-reset lifecycle.
    inputs:
      setup:
        - mage beads:init
      commands:
        - mage cobbler:measure --no-container --max-issues 1
        - bd list --json
      command: mage beads:reset
    expected:
      after_measure:
        bd_list_json_length: ">= 1"
      after_reset:
        exit_code: 0
        bd_list_json_length: 0
        state:
          beads_issues_empty: true

  - name: cobbler:measure creates 3 issues and cobbler:stitch resolves them
    description: >
      End-to-end generation cycle: measure proposes 3 issues, stitch
      picks them up one at a time (creating worktrees, invoking Claude,
      merging back), and closes each issue. After stitch completes,
      all 3 issues should have status closed and no task branches or
      worktrees should remain.
    inputs:
      setup:
        - mage beads:init
      commands:
        - mage cobbler:measure --no-container --max-issues 3
        - bd list --json
        - mage cobbler:stitch --no-container
        - bd list --json --status closed
    expected:
      after_measure:
        bd_list_json_length: 3
      after_stitch:
        exit_code: 0
        bd_list_closed_length: 3
        state:
          task_branches: none
          worktrees_clean: true
      stdout_contains: "Completed 3 task(s)"

  # ── 6. Generator lifecycle (no Claude) ──

  - name: "start/stop: creates tags and returns to main"
    description: >
      Simplest generator lifecycle. Start creates a generation branch
      and a -start tag. Stop tags -finished, merges into main, tags
      -merged, and deletes the generation branch. No run in between.
    inputs:
      setup:
        - mage reset
      commands:
        - mage generator:start
        - "BRANCH=$(git rev-parse --abbrev-ref HEAD)"
        - mage generator:stop
    expected:
      after_start:
        current_branch: "generation-*"
        tag_exists: "<branch>-start"
      after_stop:
        exit_code: 0
        current_branch: main
        generation_branches: none
        tags_exist:
          - "<branch>-finished"
          - "<branch>-merged"

  - name: "start/stop: generator:list shows merged generation"
    inputs:
      setup:
        - mage reset
      commands:
        - mage generator:start
        - mage generator:stop
        - mage generator:list
    expected:
      exit_code: 0
      stdout_contains: "tags: start, finished, merged"

  # ── 7. Generator run (requires Claude, use small limits) ──

  - name: "run 1 cycle, 1 issue: creates and resolves exactly 1 issue"
    description: >
      Start a generation, run 1 cycle with --max-issues 1. Measure
      should create 1 issue, stitch should resolve it. Stop and
      verify 1 closed issue, no stale branches, correct tags.
    inputs:
      setup:
        - mage reset
      commands:
        - mage generator:start
        - mage generator:run --cycles 1 --max-issues 1 --no-container
        - bd list --json --status closed
        - mage generator:stop
    expected:
      after_run:
        bd_list_closed_length: 1
      after_stop:
        exit_code: 0
        current_branch: main
        generation_branches: none
        task_branches: none

  - name: "run 2 cycles, 1 issue each: creates issues across cycles"
    description: >
      Run 2 measure+stitch cycles with --max-issues 1 each. After
      both cycles, at least 2 issues should be closed. Verifies
      the cycle loop works correctly.
    inputs:
      setup:
        - mage reset
      commands:
        - mage generator:start
        - mage generator:run --cycles 2 --max-issues 1 --no-container
        - bd list --json --status closed
    expected:
      bd_list_closed_length: ">= 2"

  - name: "stitch respects --max-issues: processes at most N tasks"
    description: >
      Create 3 issues via measure, then run stitch with --max-issues 1.
      Stitch should process only 1 task, leaving 2 ready. Run stitch
      again with --max-issues 1 and verify another task is processed.
    inputs:
      setup:
        - mage reset
        - mage generator:start
        - mage cobbler:measure --no-container --max-issues 3
      commands:
        - mage cobbler:stitch --no-container --max-issues 1
        - bd list --json --status closed
        - bd list --json --status ready
    expected:
      bd_list_closed_length: 1
      bd_list_ready_length: 2
      task_branches: none

  # ── 8. Generator resume (requires Claude) ──

  - name: "resume switches to generation branch and continues"
    description: >
      Start a generation, create issues via measure, switch to main,
      then resume. Resume should switch back to the generation branch,
      clean up, and run a stitch cycle to resolve the issues.
    inputs:
      setup:
        - mage reset
        - mage generator:start
        - mage cobbler:measure --no-container --max-issues 1
        - mage generator:switch main
      command: mage generator:resume --cycles 1 --max-issues 0 --no-container
    expected:
      exit_code: 0
      current_branch: "generation-*"
      bd_list_closed_length: ">= 1"
      task_branches: none

  - name: "resume auto-detects generation branch"
    description: >
      When only one generation branch exists and the user is on main,
      resume should auto-detect it without requiring a positional arg.
    inputs:
      setup:
        - mage reset
        - mage generator:start
        - mage generator:switch main
      command: mage generator:resume --cycles 1 --max-issues 1 --no-container
    expected:
      exit_code: 0
      current_branch: "generation-*"

cleanup:
  - mage reset
